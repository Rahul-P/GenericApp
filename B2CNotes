using System;
using System.Collections.Generic;

namespace B2CBroker.Domain
{
    public sealed class Application : BaseDomain, IDisposable
    {
        public Application()
        {
            Authorizations = new HashSet<Authorization>();
        }

        public string AzureApplicationId { get; set; }
        public string DisplayName { get; set; }

        public IEnumerable<Authorization> Authorizations { get; set; }

        #region Implementing Method(s), Operator Override(s) to facilitate UNIQUE HashCode.

        #endregion

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}


using System;
using System.Collections.Generic;

namespace B2CBroker.Domain
{
    public sealed class Authorization : BaseDomain, IDisposable
    {
        public Authorization()
        {
            CurrentAuthorizations = new HashSet<CurrentAuthorization>();
        }

        public string Email { get; set; }
        public Application Application { get; set; }

        public IEnumerable<CurrentAuthorization> CurrentAuthorizations { get; set; }

        #region Implementing Method(s), Operator Override(s) to facilitate UNIQUE HashCode.

        #endregion

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}


using System;
using System.Collections.Generic;

namespace B2CBroker.Domain
{
    public sealed class CurrentAuthorization : BaseDomain, IDisposable
    {
        public CurrentAuthorization()
        {
            HistoryAuthorizations = new HashSet<HistoryAuthorization>();
        }
        public string Role { get; set; }
        public int Status { get; set; }

        public Authorization Authorization { get; set; }

        public IEnumerable<HistoryAuthorization> HistoryAuthorizations { get; set; }


        #region Implementing Method(s), Operator Override(s) to facilitate UNIQUE HashCode.

        #endregion

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            GC.SuppressFinalize(this);
        }

        #endregion
    }    
}

using System;

namespace B2CBroker.Domain
{
    public sealed class HistoryAuthorization : BaseDomain, IDisposable
    {
        public string Role { get; set; }
        public int PreviousStatus { get; set; }

        public CurrentAuthorization CurrentAuthorization { get; set; }

        #region Implementing Method(s), Operator Override(s) to facilitate UNIQUE HashCode.

        #endregion

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}


using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace B2CBroker.Domain.Configuration
{
    public sealed class ApplicationConfiguration
        : BaseDomainConfiguration<Application>, System.IDisposable 
    {
        public override void Configure(EntityTypeBuilder<Application> builder)
        {
            builder.Property(p => p.AzureApplicationId).IsRequired().HasMaxLength(Misc.Constants.THREE_HUNDRED);
            builder.Property(p => p.DisplayName).IsRequired().HasMaxLength(Misc.Constants.ONE_HUNDRED);

            base.Configure(builder);
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace B2CBroker.Domain.Configuration
{
    public sealed class AuthorizationConfiguration
        : BaseDomainConfiguration<Authorization>, System.IDisposable 
    {
        public override void Configure(EntityTypeBuilder<Authorization> builder)
        {
            builder.Property(p => p.Email).IsRequired().HasMaxLength(Misc.Constants.ONE_THOUSAND);

            base.Configure(builder);
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace B2CBroker.Domain.Configuration
{
    public sealed class CurrentAuthorizationConfiguration
        : BaseDomainConfiguration<CurrentAuthorization>, System.IDisposable 
    {
        public override void Configure(EntityTypeBuilder<CurrentAuthorization> builder)
        {
            builder.Property(p => p.Role).IsRequired().HasMaxLength(Misc.Constants.ONE_HUNDRED);
            builder.Property(p => p.Status).IsRequired();

            base.Configure(builder);
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace B2CBroker.Domain.Configuration
{
    public sealed class HistoryAuthorizationConfiguration
        : BaseDomainConfiguration<HistoryAuthorization>, System.IDisposable
    {
        public override void Configure(EntityTypeBuilder<HistoryAuthorization> builder)
        {
            builder.Property(p => p.Role).IsRequired().HasMaxLength(Misc.Constants.ONE_HUNDRED);
            builder.Property(p => p.PreviousStatus).IsRequired();

            base.Configure(builder);
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


------------------------

using Functional;
using System;
using System.Threading.Tasks;

namespace B2CBroker.Data
{
    public interface IB2CBrokerRepository<T> : IDisposable
        where T : Domain.BaseDomain
    {
        #region Fetch Method(s).
        Task<Either<Error, T>> GetByStringId(string id);
        Task<Either<Error, T[]>> FetchAll(bool includeEnumerableFields = Misc.Constants.FALSE,
            int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY);
        #endregion


        #region Delete Method(s). [Set the IsDelete Flag to TRUE].
        Task<Either<Error, DatabaseOperationResult>> FlagRecordAsDeleted(string id);
        #endregion


        #region Insert Method(s).
        Task<Either<Error, DatabaseOperationResult>> SaveRecord(T domainModel);
        #endregion


        #region Update Method(s).
        Task<Either<Error, DatabaseOperationResult>> UpdateRecord(T domainModel);
        #endregion


        #region "Curry" - To Pass on additional Values to any of the above Interface Method(s) if need be.
        //Func<T1, System.Func<T2, TResult>> Curry<T1, T2, TResult>(Func<T1, T2, TResult> function);
        IB2CBrokerRepository<T> SetEssentialValues_Cheap_Curry(InputSets.InputValues valueBox);
        IB2CBrokerRepository<T> SetCurrentUserId_Cheap_Curry(InputSets.InputValues valueBox);
        #endregion
    }
}

using B2CBroker.Domain;
using B2CBroker.Domain.Configuration;
using Microsoft.EntityFrameworkCore;

namespace B2CBroker.Data
{
    public sealed class B2CBrokerContext 
        : DbContext, System.IDisposable
    {
        public DbSet<Application> Application { get; set; }
        public DbSet<Authorization> Authorization { get; set; }
        public DbSet<CurrentAuthorization> CurrentAuthorization { get; set; }
        public DbSet<HistoryAuthorization> HistoryAuthorization { get; set; }

        public B2CBrokerContext(DbContextOptions<B2CBrokerContext> options)
            : base(options)
        { }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Application>()
                .ToTable(name: Misc.Constants.Table_Application,
                        schema: Misc.Constants.Database_Schema_Present);

            modelBuilder.Entity<Authorization>()
                .ToTable(name: Misc.Constants.Table_Authorization,
                        schema: Misc.Constants.Database_Schema_Present);

            modelBuilder.Entity<CurrentAuthorization>()
                .ToTable(name: Misc.Constants.Table_CurrentAuthorization,
                        schema: Misc.Constants.Database_Schema_Present);

            modelBuilder.Entity<HistoryAuthorization>()
                .ToTable(name: Misc.Constants.Table_HistoryAuthorization,
                        schema: Misc.Constants.Database_Schema_Past);

                       
            modelBuilder.Entity<Application>()
                .HasKey(e => new { e.AzureApplicationId });

            modelBuilder.Entity<Authorization>()
                .HasKey(e => new { e.Application.AzureApplicationId, e.Email });

            modelBuilder.Entity<CurrentAuthorization>()
                .HasKey(e => new { e.Id });

            modelBuilder.Entity<HistoryAuthorization>()
                .HasKey(e => new { e.Id });

            
            modelBuilder.ApplyConfiguration(new ApplicationConfiguration());
            modelBuilder.ApplyConfiguration(new AuthorizationConfiguration());
            modelBuilder.ApplyConfiguration(new CurrentAuthorizationConfiguration());
            modelBuilder.ApplyConfiguration(new HistoryAuthorizationConfiguration());

            
            #region Ignore Soft Deleted Rows for all below entities.

            modelBuilder.Entity<Application>().HasQueryFilter(p => !p.IsDeleted);
            modelBuilder.Entity<Authorization>().HasQueryFilter(p => !p.IsDeleted);
            modelBuilder.Entity<CurrentAuthorization>().HasQueryFilter(p => !p.IsDeleted);
            modelBuilder.Entity<HistoryAuthorization>().HasQueryFilter(p => !p.IsDeleted);

            #endregion

            
            base.OnModelCreating(modelBuilder);
        }

        #region IDisposable Support                

        // This code added to correctly implement the disposable pattern.
        public override void Dispose()
        {
            base.Dispose();
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


namespace B2CBroker.Data
{
    public sealed class DatabaseOperationResult : System.IDisposable
    {
        public string OperationResult { get; private set; }
        public bool IsSuccess { get; private set; }

        public DatabaseOperationResult(string _passedOperationResult, bool _passedIsSuccess)
        {
            this.OperationResult = _passedOperationResult;
            this.IsSuccess = _passedIsSuccess;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}

namespace B2CBroker.Data.InputSets
{
    public struct InputValues
    {
        public string RequiredValue;

        public InputValues(string _value) =>
            this.RequiredValue = _value;
    }
}



namespace B2CBroker.Data.Errors
{
    public sealed class ApplicationNotAdded : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public ApplicationNotAdded(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}

namespace B2CBroker.Data.Errors
{

    public sealed class ApplicationNotDeleted : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public ApplicationNotDeleted(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}

namespace B2CBroker.Data.Errors
{
    public sealed class ApplicationNotFound : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public ApplicationNotFound(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}

namespace B2CBroker.Data.Errors
{
    public sealed class ApplicationNotUpdated : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public ApplicationNotUpdated(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}

namespace B2CBroker.Data.Errors
{

    public sealed class AuthorizationNotAdded : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public AuthorizationNotAdded(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


namespace B2CBroker.Data.Errors
{
    public sealed class AuthorizationNotDeleted : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public AuthorizationNotDeleted(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}

namespace B2CBroker.Data.Errors
{
    public sealed class AuthorizationNotFound : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public AuthorizationNotFound(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}



namespace B2CBroker.Data.Errors
{
    public sealed class AuthorizationNotUpdated : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public AuthorizationNotUpdated(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}
namespace B2CBroker.Data.Errors
{

    public sealed class CurrentAuthorizationNotAdded : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public CurrentAuthorizationNotAdded(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


namespace B2CBroker.Data.Errors
{
    public sealed class CurrentAuthorizationNotDeleted : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public CurrentAuthorizationNotDeleted(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}



namespace B2CBroker.Data.Errors
{
    public sealed class CurrentAuthorizationNotFound : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public CurrentAuthorizationNotFound(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}



namespace B2CBroker.Data.Errors
{
    public sealed class CurrentAuthorizationNotUpdated : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public CurrentAuthorizationNotUpdated(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}

namespace B2CBroker.Data.Errors
{
    public sealed class HistoryAuthorizationNotAdded : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public HistoryAuthorizationNotAdded(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}



namespace B2CBroker.Data.Errors
{
    public sealed class HistoryAuthorizationNotDeleted : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public HistoryAuthorizationNotDeleted(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}



namespace B2CBroker.Data.Errors
{
    public sealed class HistoryAuthorizationNotFound : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public HistoryAuthorizationNotFound(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}


namespace B2CBroker.Data.Errors
{
    public sealed class HistoryAuthorizationNotUpdated : Functional.Error, System.IDisposable
    {
        public string _reason { get; }

        public HistoryAuthorizationNotUpdated(string reason)
        {
            this._reason = reason;
        }

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            System.GC.SuppressFinalize(this);
        }

        #endregion
    }
}
----- Repso



using B2CBroker.Data.Errors;
using B2CBroker.Domain;
using Functional;
using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace B2CBroker.Data
{
    public sealed class ApplicationRepository : IB2CBrokerRepository<Application>
    {
        private B2CBrokerContext _context;
        private Performance.TaskJaguar _taskJaguar;

        private string _azureApplicationId = string.Empty;
        private string _currentUserId = string.Empty;

        public ApplicationRepository(B2CBrokerContext context)
        {
            _context = context;
            _taskJaguar = new Performance.TaskJaguar();
        }

        public IB2CBrokerRepository<Application> SetEssentialValues_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _azureApplicationId = valueBox.RequiredValue;
            return this;
        }
        

        public IB2CBrokerRepository<Application> SetCurrentUserId_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _currentUserId = valueBox.RequiredValue;
            return this;
        }
            

        public async Task<Either<Error, Application>> GetByStringId(string id) =>
            await TryCatch.FireTaskAndProcessAsync<string, Application>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<string, Task<Application>>
                        (id,        // The argument that the task expects
                        async (_id, _token) =>
                        {
                            Application _application = await _context
                                .Application
                                .Include(a => a.Authorizations)
                                .FirstOrDefaultAsync(u => u.AzureApplicationId == _id); 
                            return _application;
                        },          // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new ApplicationNotFound(Misc.Constants.Error_ApplicationNotFound + id);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                id);


        public async Task<Either<Error, Application[]>> FetchAll(bool includeEnumerableFields = Misc.Constants.FALSE,
            int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await TryCatch.FireTaskAndProcessAsync<bool, Application[]>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<bool, Task<Application[]>>
                        (includeEnumerableFields,        // The argument that the task expects
                        async (_includeEnumerableFields, _token) =>
                        {
                            IQueryable<Application> query = _context.Application;

                            if (_azureApplicationId != string.Empty)
                                query = query.Where(application => application.AzureApplicationId == _azureApplicationId);

                            if (_includeEnumerableFields)
                                query = query.Include(c => c.Authorizations);

                            query = query.Skip(skipRows).Take(takeRows);        // Skip and take Airlines                      
                            query = query.OrderByDescending(c => c.CreatedOn);  // Order Airlines

                            return await query.ToArrayAsync();
                        },          // The Code Bloak to excute as Task Code
                        null)),     // Null for Cancellation token Source                                    
                (_e, h) =>          // The Exception Block Code
                {
                    return new NoDataFound(Misc.Constants.Message_NoDataFound);
                },
                () =>               // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                includeEnumerableFields);

        public async Task<Either<Error, DatabaseOperationResult>> FlagRecordAsDeleted(string applicationId) =>
            await TryCatch.FireTaskAndProcessAsync<string, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<string, Task<DatabaseOperationResult>>
                            (applicationId,        // The argument that the task expects
                            async (_applicationId, _token) =>
                            {
                                Application _application = await _context.Application
                                    .FirstOrDefaultAsync(u => u.AzureApplicationId == _applicationId); // && u.IsDeleted == Misc.Constant.FALSE);

                                if (_application != null)
                                {
                                    _application.IsDeleted = Misc.Constants.TRUE; // Enforce deletion, whatif -> Controller code did not flag it as deleted.                                    
                                    this._context.Application.Update(_application);
                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_ApplicationDeleted, Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_ApplicationNotDeleted_Because_NotFound, Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new ApplicationNotDeleted(Misc.Constants.Message_ApplicationNotDeleted);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    applicationId);

        public async Task<Either<Error, DatabaseOperationResult>> SaveRecord(Application domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<Application, DatabaseOperationResult>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<Application, Task<DatabaseOperationResult>>
                        (domainModel,        // The argument that the task expects
                        async (_domainModel, _token) =>
                        {
                            if (!await this._context.Application.AnyAsync(_c => _c.AzureApplicationId == _domainModel.AzureApplicationId)) 
                            {
                                _domainModel.CreatedBy = this._currentUserId; // This will be logged in User Id.
                                _domainModel.LastModifiedBy = this._currentUserId; // This will be logged in User Id.

                                await this._context.Application.AddAsync(_domainModel);

                                if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                    return new DatabaseOperationResult(Misc.Constants.Message_ApplicationAdded, Misc.Constants.TRUE);
                            }
                            return new DatabaseOperationResult(Misc.Constants.Message_ApplicationNotAdded_Because_Exists, Misc.Constants.FALSE);
                        },  // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new ApplicationNotAdded(Misc.Constants.Message_ApplicationNotAdded);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally.                    
                },
                domainModel);


        public async Task<Either<Error, DatabaseOperationResult>> UpdateRecord(Application domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<Application, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<Application, Task<DatabaseOperationResult>>
                            (domainModel,        // The argument that the task expects
                            async (_domainModel, _token) =>
                            {
                                Application _toBeUpdatedEntity = await this._context.Application
                                        .FirstOrDefaultAsync(_c => _c.AzureApplicationId == _domainModel.AzureApplicationId);

                                if (_toBeUpdatedEntity != null)
                                {
                                    this._context.Application.Update(MapApplication(_toBeUpdatedEntity, domainModel));

                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_ApplicationUpdated, Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_ApplicationNotUpdated_Because_NotFound, Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new ApplicationNotUpdated(Misc.Constants.Message_ApplicationNotUpdated);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    domainModel);



        #region Private(s)

        private Application MapApplication(Application _modelFromDatabase, Application _modelFromCurrentRequest)
        {
            _modelFromDatabase.DisplayName = _modelFromCurrentRequest.DisplayName;
            _modelFromDatabase.LastModifiedOn = System.DateTime.UtcNow;
            _modelFromDatabase.LastModifiedBy = this._currentUserId; // This will be logged in User Id.
            return _modelFromDatabase;
        }

        #endregion


        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            _context = null;
            _taskJaguar = null;
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}









using B2CBroker.Data.Errors;
using B2CBroker.Domain;
using Functional;
using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace B2CBroker.Data
{
    public sealed class AuthorizationRepository : IB2CBrokerRepository<Authorization>
    {
        private B2CBrokerContext _context;
        private Performance.TaskJaguar _taskJaguar;

        private string _azureApplicationId = string.Empty;
        private string _currentUserId = string.Empty;

        public AuthorizationRepository(B2CBrokerContext context)
        {
            _context = context;
            _taskJaguar = new Performance.TaskJaguar();
        }

        public IB2CBrokerRepository<Authorization> SetEssentialValues_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _azureApplicationId = valueBox.RequiredValue;
            return this;
        }
         

        public IB2CBrokerRepository<Authorization> SetCurrentUserId_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _currentUserId = valueBox.RequiredValue;
            return this;
        }


        public async Task<Either<Error, Authorization>> GetByStringId(string id) =>
            await TryCatch.FireTaskAndProcessAsync<string, Authorization>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<string, Task<Authorization>>
                        (id,        // The argument that the task expects
                        async (_id, _token) =>
                        {
                            Authorization _authorization = await _context
                                .Authorization
                                .Include(a => a.CurrentAuthorizations)
                                .FirstOrDefaultAsync(u => u.Email == _id); 
                            return _authorization;
                        },          // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new AuthorizationNotFound(Misc.Constants.Error_AuthorizationNotFound + id);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                id);

        public async Task<Either<Error, Authorization[]>> FetchAll(bool includeEnumerableFields = Misc.Constants.FALSE,
            int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await TryCatch.FireTaskAndProcessAsync<bool, Authorization[]>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<bool, Task<Authorization[]>>
                        (includeEnumerableFields,        // The argument that the task expects
                        async (_includeEnumerableFields, _token) =>
                        {
                            IQueryable<Authorization> query = _context.Authorization; //_azureApplicationId

                            if (_azureApplicationId != string.Empty)
                                query = query.Where(authorization => authorization.Application.AzureApplicationId == _azureApplicationId);

                            if (_includeEnumerableFields)
                                query = query.Include(c => c.CurrentAuthorizations);

                            query = query.Skip(skipRows).Take(takeRows);        // Skip and take Airlines                      
                            query = query.OrderByDescending(c => c.CreatedOn);  // Order Airlines

                            return await query.ToArrayAsync();
                        },          // The Code Bloak to excute as Task Code
                        null)),     // Null for Cancellation token Source                                    
                (_e, h) =>          // The Exception Block Code
                {
                    return new NoDataFound(Misc.Constants.Message_NoDataFound);
                },
                () =>               // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                includeEnumerableFields);


        public async Task<Either<Error, DatabaseOperationResult>> FlagRecordAsDeleted(string authorizationId) =>
            await TryCatch.FireTaskAndProcessAsync<string, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<string, Task<DatabaseOperationResult>>
                            (authorizationId,        // The argument that the task expects
                            async (_authorizationId, _token) =>
                            {
                                Authorization _authorization = await _context.Authorization
                                    .FirstOrDefaultAsync(u => u.Email == _authorizationId); 

                                if (_authorization != null)
                                {
                                    // Enforce deletion, whatif -> Controller code did not flag it as deleted.
                                    _authorization.IsDeleted = Misc.Constants.TRUE;                                     
                                    this._context.Authorization.Update(_authorization);
                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_AuthorizationDeleted, Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_AuthorizationNotDeleted_Because_NotFound, Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new AuthorizationNotDeleted(Misc.Constants.Message_AuthorizationNotDeleted);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    authorizationId);

        public async Task<Either<Error, DatabaseOperationResult>> SaveRecord(Authorization domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<Authorization, DatabaseOperationResult>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<Authorization, Task<DatabaseOperationResult>>
                        (domainModel,        // The argument that the task expects
                        async (_domainModel, _token) =>
                        {
                            if (!await this._context.Authorization.AnyAsync(_c => _c.Email == _domainModel.Email))
                            {
                                _domainModel.CreatedBy = this._currentUserId; // This will be logged in User Id.
                                _domainModel.LastModifiedBy = this._currentUserId; // This will be logged in User Id.

                                await this._context.Authorization.AddAsync(_domainModel);

                                if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                    return new DatabaseOperationResult(Misc.Constants.Message_AuthorizationAdded, Misc.Constants.TRUE);
                            }
                            return new DatabaseOperationResult(Misc.Constants.Message_AuthorizationNotAdded_Because_Exists,
                                Misc.Constants.FALSE);
                        },  // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new AuthorizationNotAdded(Misc.Constants.Message_AuthorizationNotAdded);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally.                    
                },
                domainModel);


        public async Task<Either<Error, DatabaseOperationResult>> UpdateRecord(Authorization domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<Authorization, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<Authorization, Task<DatabaseOperationResult>>
                            (domainModel,        // The argument that the task expects
                            async (_domainModel, _token) =>
                            {
                                Authorization _toBeUpdatedEntity = await this._context.Authorization
                                        .FirstOrDefaultAsync(_c => _c.Email == _domainModel.Email);

                                if (_toBeUpdatedEntity != null)
                                {
                                    this._context.Authorization.Update(MapAuthorization(_toBeUpdatedEntity, domainModel));

                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_AuthorizationUpdated, 
                                            Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_AuthorizationNotUpdated_Because_NotFound,
                                    Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new AuthorizationNotUpdated(Misc.Constants.Message_AuthorizationNotUpdated);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    domainModel);




        #region Private(s)

        private Authorization MapAuthorization(Authorization _modelFromDatabase, Authorization _modelFromCurrentRequest)
        {
            //_modelFromDatabase.Email = _modelFromCurrentRequest.Email;
            _modelFromDatabase.LastModifiedOn = System.DateTime.UtcNow;
            _modelFromDatabase.LastModifiedBy = this._currentUserId; // This will be logged in User Id.
            return _modelFromDatabase;
        }

        #endregion

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            _context = null;
            _taskJaguar = null;
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}





using B2CBroker.Data.Errors;
using B2CBroker.Domain;
using Functional;
using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace B2CBroker.Data
{
    public sealed class CurrentAuthorizationRepository : IB2CBrokerRepository<CurrentAuthorization>
    {
        private B2CBrokerContext _context;
        private Performance.TaskJaguar _taskJaguar;

        private string _emailOfUserToFetchCurrentAuthrorization = string.Empty;
        private string _currentUserId = string.Empty;

        public CurrentAuthorizationRepository(B2CBrokerContext context)
        {
            _context = context;
            _taskJaguar = new Performance.TaskJaguar();
        }

        public IB2CBrokerRepository<CurrentAuthorization> SetEssentialValues_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _emailOfUserToFetchCurrentAuthrorization = valueBox.RequiredValue;
            return this;
        }

        public IB2CBrokerRepository<CurrentAuthorization> SetCurrentUserId_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _currentUserId = valueBox.RequiredValue;
            return this;
        }


        public async Task<Either<Error, CurrentAuthorization>> GetByStringId(string id) =>
            await TryCatch.FireTaskAndProcessAsync<string, CurrentAuthorization>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<string, Task<CurrentAuthorization>>
                        (id,        // The argument that the task expects
                        async (_id, _token) =>
                        {
                            int parsedId = Int32.Parse(_id);
                            CurrentAuthorization _currentAuthorization = await _context
                                .CurrentAuthorization
                                .Include(a => a.HistoryAuthorizations)
                                .FirstOrDefaultAsync(u => u.Id == parsedId);
                            return _currentAuthorization;
                        },          // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new CurrentAuthorizationNotFound(Misc.Constants.Error_CurrentAuthorizationNotFound + id);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                id);

        public async Task<Either<Error, CurrentAuthorization[]>> FetchAll(bool includeEnumerableFields = Misc.Constants.FALSE,
            int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await TryCatch.FireTaskAndProcessAsync<bool, CurrentAuthorization[]>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<bool, Task<CurrentAuthorization[]>>
                        (includeEnumerableFields,        // The argument that the task expects
                        async (_includeEnumerableFields, _token) =>
                        {
                            IQueryable<CurrentAuthorization> query = _context.CurrentAuthorization;

                            if (_emailOfUserToFetchCurrentAuthrorization != string.Empty)
                                query = query.Where(currentAuthorization =>
                                    currentAuthorization.Authorization.Email == _emailOfUserToFetchCurrentAuthrorization);

                            if (_includeEnumerableFields)
                                query = query.Include(c => c.HistoryAuthorizations);

                            query = query.Skip(skipRows).Take(takeRows);        // Skip and take Airlines                      
                            query = query.OrderByDescending(c => c.CreatedOn);  // Order Airlines

                            return await query.ToArrayAsync();
                        },          // The Code Bloak to excute as Task Code
                        null)),     // Null for Cancellation token Source                                    
                (_e, h) =>          // The Exception Block Code
                {
                    return new NoDataFound(Misc.Constants.Message_NoDataFound);
                },
                () =>               // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                includeEnumerableFields);


        public async Task<Either<Error, DatabaseOperationResult>> FlagRecordAsDeleted(string currentAuthorizationId) =>
            await TryCatch.FireTaskAndProcessAsync<string, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<string, Task<DatabaseOperationResult>>
                            (currentAuthorizationId,        // The argument that the task expects
                            async (_currentAuthorizationId, _token) =>
                            {
                                int parsedId = Int32.Parse(_currentAuthorizationId);
                                CurrentAuthorization _currentAuthorization = await _context.CurrentAuthorization
                                    .FirstOrDefaultAsync(u => u.Id == parsedId);

                                if (_currentAuthorization != null)
                                {
                                    // Enforce deletion, whatif -> Controller code did not flag it as deleted.
                                    _currentAuthorization.IsDeleted = Misc.Constants.TRUE;
                                    this._context.CurrentAuthorization.Update(_currentAuthorization);
                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_CurrentAuthorizationDeleted,
                                            Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_CurrentAuthorizationNotDeleted_Because_NotFound, Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new CurrentAuthorizationNotDeleted(Misc.Constants.Message_CurrentAuthorizationNotDeleted);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    currentAuthorizationId);

        public async Task<Either<Error, DatabaseOperationResult>> SaveRecord(CurrentAuthorization domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<CurrentAuthorization, DatabaseOperationResult>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<CurrentAuthorization, Task<DatabaseOperationResult>>
                        (domainModel,        // The argument that the task expects
                        async (_domainModel, _token) =>
                        {
                            if (!await this._context.CurrentAuthorization.AnyAsync(_c => _c.Id == _domainModel.Id))
                            {
                                _domainModel.CreatedBy = this._currentUserId; // This will be logged in User Id.
                                _domainModel.LastModifiedBy = this._currentUserId; // This will be logged in User Id.

                                await this._context.CurrentAuthorization.AddAsync(_domainModel);

                                if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                    return new DatabaseOperationResult(Misc.Constants.Message_CurrentAuthorizationAdded, 
                                        Misc.Constants.TRUE);
                            }
                            return new DatabaseOperationResult(Misc.Constants.Message_CurrentAuthorizationNotAdded_Because_Exists,
                                Misc.Constants.FALSE);
                        },  // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new CurrentAuthorizationNotAdded(Misc.Constants.Message_CurrentAuthorizationNotAdded);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally.                    
                },
                domainModel);


        public async Task<Either<Error, DatabaseOperationResult>> UpdateRecord(CurrentAuthorization domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<CurrentAuthorization, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<CurrentAuthorization, Task<DatabaseOperationResult>>
                            (domainModel,        // The argument that the task expects
                            async (_domainModel, _token) =>
                            {
                                CurrentAuthorization _toBeUpdatedEntity = await this._context.CurrentAuthorization
                                        .FirstOrDefaultAsync(_c => _c.Id == _domainModel.Id);

                                if (_toBeUpdatedEntity != null)
                                {
                                    this._context.CurrentAuthorization.Update(MapCurrentAuthorization(_toBeUpdatedEntity, domainModel));

                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_CurrentAuthorizationUpdated,
                                            Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_CurrentAuthorizationNotUpdated_Because_NotFound,
                                    Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new CurrentAuthorizationNotUpdated(Misc.Constants.Message_CurrentAuthorizationNotUpdated);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    domainModel);




        #region Private(s)

        private CurrentAuthorization MapCurrentAuthorization(CurrentAuthorization _modelFromDatabase, CurrentAuthorization _modelFromCurrentRequest)
        {
            _modelFromDatabase.Status = _modelFromCurrentRequest.Status;
            _modelFromDatabase.LastModifiedOn = System.DateTime.UtcNow;
            _modelFromDatabase.LastModifiedBy = this._currentUserId; // This will be logged in User Id.
            return _modelFromDatabase;
        }

        #endregion

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            _context = null;
            _taskJaguar = null;
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}





using B2CBroker.Data.Errors;
using B2CBroker.Domain;
using Functional;
using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace B2CBroker.Data
{
    public sealed class HistoryAuthorizationRepository : IB2CBrokerRepository<HistoryAuthorization>
    {
        private B2CBrokerContext _context;
        private Performance.TaskJaguar _taskJaguar;

        private string _emailOfUserToFetchCurrentAuthrorization = string.Empty;
        private string _currentUserId = string.Empty;

        public HistoryAuthorizationRepository(B2CBrokerContext context)
        {
            _context = context;
            _taskJaguar = new Performance.TaskJaguar();
        }

        public IB2CBrokerRepository<HistoryAuthorization> SetEssentialValues_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _emailOfUserToFetchCurrentAuthrorization = valueBox.RequiredValue;
            return this;
        }
     


        public IB2CBrokerRepository<HistoryAuthorization> SetCurrentUserId_Cheap_Curry(InputSets.InputValues valueBox)
        {
            _currentUserId = valueBox.RequiredValue;
            return this;
        }


        public async Task<Either<Error, HistoryAuthorization>> GetByStringId(string id) =>
            await TryCatch.FireTaskAndProcessAsync<string, HistoryAuthorization>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<string, Task<HistoryAuthorization>>
                        (id,        // The argument that the task expects
                        async (_id, _token) =>
                        {
                            int parsedId = Int32.Parse(_id);
                            HistoryAuthorization _historyAuthorization = await _context
                                .HistoryAuthorization
                                .FirstOrDefaultAsync(u => u.Id == parsedId);
                            return _historyAuthorization;
                        },          // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new HistoryAuthorizationNotFound(Misc.Constants.Error_HistoryAuthorizationNotFound + id);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                id);

        public async Task<Either<Error, HistoryAuthorization[]>> FetchAll(bool includeEnumerableFields = Misc.Constants.FALSE,
            int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await TryCatch.FireTaskAndProcessAsync<bool, HistoryAuthorization[]>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<bool, Task<HistoryAuthorization[]>>
                        (includeEnumerableFields,        // The argument that the task expects
                        async (_includeEnumerableFields, _token) =>
                        {
                            IQueryable<HistoryAuthorization> query = _context.HistoryAuthorization;

                            if (_emailOfUserToFetchCurrentAuthrorization != string.Empty)
                                query = query.Where(historyAuthorization =>
                                    historyAuthorization.CurrentAuthorization.Authorization.Email == 
                                        _emailOfUserToFetchCurrentAuthrorization);

                            query = query.Skip(skipRows).Take(takeRows);        // Skip and take Airlines                      
                            query = query.OrderByDescending(c => c.CreatedOn);  // Order Airlines

                            return await query.ToArrayAsync();
                        },          // The Code Bloak to excute as Task Code
                        null)),     // Null for Cancellation token Source                                    
                (_e, h) =>          // The Exception Block Code
                {
                    return new NoDataFound(Misc.Constants.Message_NoDataFound);
                },
                () =>               // The Finally Block Code
                {
                    // Nothing for Finally. 
                },
                includeEnumerableFields);


        public async Task<Either<Error, DatabaseOperationResult>> FlagRecordAsDeleted(string historyAuthorizationId) =>
            await TryCatch.FireTaskAndProcessAsync<string, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<string, Task<DatabaseOperationResult>>
                            (historyAuthorizationId,        // The argument that the task expects
                            async (_historyAuthorizationId, _token) =>
                            {
                                int parsedId = Int32.Parse(_historyAuthorizationId);
                                HistoryAuthorization _historyAuthorization = await _context.HistoryAuthorization
                                    .FirstOrDefaultAsync(u => u.Id == parsedId);

                                if (_historyAuthorization != null)
                                {
                                    // Enforce deletion, whatif -> Controller code did not flag it as deleted.
                                    _historyAuthorization.IsDeleted = Misc.Constants.TRUE;
                                    this._context.HistoryAuthorization.Update(_historyAuthorization);
                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_HistoryAuthorizationDeleted,
                                            Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_HistoryAuthorizationNotDeleted_Because_NotFound, Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new HistoryAuthorizationNotDeleted(Misc.Constants.Message_HistoryAuthorizationNotDeleted);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    historyAuthorizationId);

        public async Task<Either<Error, DatabaseOperationResult>> SaveRecord(HistoryAuthorization domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<HistoryAuthorization, DatabaseOperationResult>
                (await new Performance.TaskJaguar().Use(obj =>
                    obj.CreateTask<HistoryAuthorization, Task<DatabaseOperationResult>>
                        (domainModel,        // The argument that the task expects
                        async (_domainModel, _token) =>
                        {
                            if (!await this._context.HistoryAuthorization.AnyAsync(_c => _c.Id == _domainModel.Id))
                            {
                                _domainModel.CreatedBy = this._currentUserId; // This will be logged in User Id.
                                _domainModel.LastModifiedBy = this._currentUserId; // This will be logged in User Id.

                                await this._context.HistoryAuthorization.AddAsync(_domainModel);

                                if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                    return new DatabaseOperationResult(Misc.Constants.Message_HistoryAuthorizationAdded, 
                                        Misc.Constants.TRUE);
                            }
                            return new DatabaseOperationResult(Misc.Constants.Message_HistoryAuthorizationNotAdded_Because_Exists,
                                Misc.Constants.FALSE);
                        },  // The Code Bloak to excute as Task Code
                        null)), // Null for Cancellation token Source                                    
                (_e, h) =>  // The Exception Block Code
                {
                    return new HistoryAuthorizationNotAdded(Misc.Constants.Message_HistoryAuthorizationNotAdded);
                },
                () =>       // The Finally Block Code
                {
                    // Nothing for Finally.                    
                },
                domainModel);


        public async Task<Either<Error, DatabaseOperationResult>> UpdateRecord(HistoryAuthorization domainModel) =>
            await TryCatch.FireTaskAndProcessAsync<HistoryAuthorization, DatabaseOperationResult>
                    (await new Performance.TaskJaguar().Use(obj =>
                        obj.CreateTask<HistoryAuthorization, Task<DatabaseOperationResult>>
                            (domainModel,        // The argument that the task expects
                            async (_domainModel, _token) =>
                            {
                                HistoryAuthorization _toBeUpdatedEntity = await this._context.HistoryAuthorization
                                        .FirstOrDefaultAsync(_c => _c.Id == _domainModel.Id);

                                if (_toBeUpdatedEntity != null)
                                {
                                    this._context.HistoryAuthorization.Update(MapHistoryAuthorization(_toBeUpdatedEntity, domainModel));

                                    if (await _context.SaveChangesAsync() > Misc.Constants.ZERO)
                                        return new DatabaseOperationResult(Misc.Constants.Message_HistoryAuthorizationUpdated,
                                            Misc.Constants.TRUE);
                                }
                                return new DatabaseOperationResult(Misc.Constants.Message_HistoryAuthorizationNotUpdated_Because_NotFound,
                                    Misc.Constants.FALSE);
                            },  // The Code Bloak to excute as Task Code
                            null)), // Null for Cancellation token Source                                    
                    (_e, h) =>  // The Exception Block Code
                    {
                        return new HistoryAuthorizationNotUpdated(Misc.Constants.Message_HistoryAuthorizationNotUpdated);
                    },
                    () =>       // The Finally Block Code
                    {
                        // Nothing for Finally. 
                    },
                    domainModel);




        #region Private(s)

        private HistoryAuthorization MapHistoryAuthorization(HistoryAuthorization _modelFromDatabase, HistoryAuthorization _modelFromCurrentRequest)
        {
            // No Updates for History Tables.
            _modelFromDatabase.LastModifiedOn = System.DateTime.UtcNow;
            _modelFromDatabase.LastModifiedBy = this._currentUserId; // This will be logged in User Id.
            return _modelFromDatabase;
        }

        #endregion

        #region IDisposable Support        

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            _context = null;
            _taskJaguar = null;
            GC.SuppressFinalize(this);
        }

        #endregion

    }
}











---- repos






using B2CBroker.Data;
using B2CBroker.Domain;
using Functional;
using System;
using System.Threading.Tasks;

namespace B2CBroker.Business
{
    public sealed class Orchestrator : IDisposable
    {
        public Orchestrator()
        { }

        #region Business Method(s) pertaining to "Application".

        public async Task<Either<Error, Application>> GetApplicationByStringId(string id, string currentUserId,
            IB2CBrokerRepository<Application> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .GetByStringId(id);

        public async Task<Either<Error, Application[]>> GetApplications(string currentUserId, string currentAzureApplicationId, IB2CBrokerRepository<Application> _passedRepo, 
            bool includeEnumerableFields = Misc.Constants.FALSE, int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentAzureApplicationId))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FetchAll(includeEnumerableFields, skipRows, takeRows);

        public async Task<Either<Error, DatabaseOperationResult>> SaveApplication(string currentUserId, Application _passedApplication, 
            IB2CBrokerRepository<Application> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .SaveRecord(_passedApplication);

        public async Task<Either<Error, DatabaseOperationResult>> UpdateApplication(string currentUserId, Application _passedApplication, 
            IB2CBrokerRepository<Application> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .UpdateRecord(_passedApplication);

        public async Task<Either<Error, DatabaseOperationResult>> DeleteApplication(string currentUserId, string _passedApplicationId, 
            IB2CBrokerRepository<Application> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FlagRecordAsDeleted(_passedApplicationId);

        #endregion  

        #region Business Method(s) pertaining to "Authorization".

        public async Task<Either<Error, Authorization>> GetAuthorizationByStringId(string id, string currentUserId,
            IB2CBrokerRepository<Authorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .GetByStringId(id);

        public async Task<Either<Error, Authorization[]>> GetAuthorizations(string currentUserId, string currentAzureApplicationId, IB2CBrokerRepository<Authorization> _passedRepo,
            bool includeEnumerableFields = Misc.Constants.FALSE, int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentAzureApplicationId))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FetchAll(includeEnumerableFields, skipRows, takeRows);

        public async Task<Either<Error, DatabaseOperationResult>> SaveAuthorization(string currentUserId, Authorization _passedAuthorization,
            IB2CBrokerRepository<Authorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .SaveRecord(_passedAuthorization);

        public async Task<Either<Error, DatabaseOperationResult>> UpdateAuthorization(string currentUserId, Authorization _passedAuthorization,
            IB2CBrokerRepository<Authorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .UpdateRecord(_passedAuthorization);

        public async Task<Either<Error, DatabaseOperationResult>> DeleteAuthorization(string currentUserId, string _passedAuthorizationId,
            IB2CBrokerRepository<Authorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FlagRecordAsDeleted(_passedAuthorizationId);

        #endregion


        #region Business Method(s) pertaining to "CurrentAuthorization".

        public async Task<Either<Error, CurrentAuthorization>> GetCurrentAuthorizationByStringId(string id, string currentUserId,
            IB2CBrokerRepository<CurrentAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .GetByStringId(id);

        public async Task<Either<Error, CurrentAuthorization[]>> GetCurrentAuthorizations(string currentUserId, string currentEmailAddress, 
            IB2CBrokerRepository<CurrentAuthorization> _passedRepo,
            bool includeEnumerableFields = Misc.Constants.FALSE, int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentEmailAddress))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FetchAll(includeEnumerableFields, skipRows, takeRows);

        public async Task<Either<Error, DatabaseOperationResult>> SaveCurrentAuthorization(string currentUserId, CurrentAuthorization _passedCurrentAuthorization,
            IB2CBrokerRepository<CurrentAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .SaveRecord(_passedCurrentAuthorization);

        public async Task<Either<Error, DatabaseOperationResult>> UpdateCurrentAuthorization(string currentUserId, CurrentAuthorization _passedCurrentAuthorization,
            IB2CBrokerRepository<CurrentAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .UpdateRecord(_passedCurrentAuthorization);

        public async Task<Either<Error, DatabaseOperationResult>> DeleteCurrentAuthorization(string currentUserId, string _passedCurrentAuthorizationId,
            IB2CBrokerRepository<CurrentAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FlagRecordAsDeleted(_passedCurrentAuthorizationId);

        #endregion


        #region Business Method(s) pertaining to "CurrentAuthorization".

        public async Task<Either<Error, HistoryAuthorization>> GetHistoryAuthorizationByStringId(string id, string currentUserId,
            IB2CBrokerRepository<HistoryAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .GetByStringId(id);

        public async Task<Either<Error, HistoryAuthorization[]>> GetHistoryAuthorizations(string currentUserId, string currentEmailAddress,
            IB2CBrokerRepository<HistoryAuthorization> _passedRepo,
            bool includeEnumerableFields = Misc.Constants.FALSE, int skipRows = Misc.Constants.ZERO, int takeRows = Misc.Constants.TWENTY) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentEmailAddress))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FetchAll(includeEnumerableFields, skipRows, takeRows);

        public async Task<Either<Error, DatabaseOperationResult>> SaveHistoryAuthorization(string currentUserId, HistoryAuthorization _passedHistoryAuthorization,
            IB2CBrokerRepository<HistoryAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .SaveRecord(_passedHistoryAuthorization);

        public async Task<Either<Error, DatabaseOperationResult>> UpdateHistoryAuthorization(string currentUserId, HistoryAuthorization _passedHistoryAuthorization,
            IB2CBrokerRepository<HistoryAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .UpdateRecord(_passedHistoryAuthorization);

        public async Task<Either<Error, DatabaseOperationResult>> DeleteHistoryAuthorization(string currentUserId, string _passedHistoryAuthorizationId,
            IB2CBrokerRepository<HistoryAuthorization> _passedRepo) =>
            await _passedRepo
                .SetEssentialValues_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(string.Empty))
                .SetCurrentUserId_Cheap_Curry(new B2CBroker.Data.InputSets.InputValues(currentUserId))
                .FlagRecordAsDeleted(_passedHistoryAuthorizationId);

        #endregion


        #region IDisposable Support                    

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            /*** 
             * SuppressFinalize tells the GC that the object was 
             * cleaned up properly and doesn't need to go onto the 
             * finalizer queue. 
            ***/
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}





#region Databse Related

        public const string SQL_Server_GetDate_Function = "getdate()";

        public const string Database_Schema_Present = "Present";
        public const string Database_Schema_Past = "Past";

        public const string Table_Application = "Application";
        public const string Table_Authorization = "Authorization";
        public const string Table_CurrentAuthorization = "CurrentAuthorization";
        public const string Table_HistoryAuthorization = "HistoryAuthorization";

        #endregion

        #region Repository Errors

        public const string Message_NoDataFound = "Requested data could not be found!";

        public const string Error_ApplicationNotFound = "Failed! to find Application with supplied Id of: ";        
        public const string Message_ApplicationDeleted = "Provided application details have been deleted in system.";
        public const string Message_ApplicationNotDeleted_Because_NotFound = "Provided application details could not be found in system and hence no details have been deleted.";
        public const string Message_ApplicationNotDeleted = "Failed to delete provided application details. Please try again.";
        public const string Message_ApplicationAdded = "Provided application details have been saved in system.";
        public const string Message_ApplicationNotAdded_Because_Exists = "Application with provided details already exists in system.";
        public const string Message_ApplicationNotAdded = "Failed to add/save the provided application details. Please try again.";
        public const string Message_ApplicationUpdated = "Provided application details have been updated in system.";
        public const string Message_ApplicationNotUpdated_Because_NotFound = "Provided application details could not be found in system and hence no details have been updated.";
        public const string Message_ApplicationNotUpdated = "Failed to update provided application details. Please try again.";

        public const string Error_AuthorizationNotFound = "Failed! to find Authorization with supplied Id of: ";
        public const string Message_AuthorizationDeleted = "Provided authorization details have been deleted in system.";
        public const string Message_AuthorizationNotDeleted_Because_NotFound = "Provided authorization details could not be found in system and hence no details have been deleted.";
        public const string Message_AuthorizationNotDeleted = "Failed to delete provided authorization details. Please try again.";
        public const string Message_AuthorizationAdded = "Provided authorization details have been saved in system.";
        public const string Message_AuthorizationNotAdded_Because_Exists = "Authorization with provided details already exists in system.";
        public const string Message_AuthorizationNotAdded = "Failed to add/save the provided authorization details. Please try again.";
        public const string Message_AuthorizationUpdated = "Provided authorization details have been updated in system.";
        public const string Message_AuthorizationNotUpdated_Because_NotFound = "Provided authorization details could not be found in system and hence no details have been updated.";
        public const string Message_AuthorizationNotUpdated = "Failed to update provided authorization details. Please try again.";

        public const string Error_CurrentAuthorizationNotFound = "Failed! to find CurrentAuthorization with supplied Id of: ";
        public const string Message_CurrentAuthorizationDeleted = "Provided currentauthorization details have been deleted in system.";
        public const string Message_CurrentAuthorizationNotDeleted_Because_NotFound = "Provided currentauthorization details could not be found in system and hence no details have been deleted.";
        public const string Message_CurrentAuthorizationNotDeleted = "Failed to delete provided currentauthorization details. Please try again.";
        public const string Message_CurrentAuthorizationAdded = "Provided currentauthorization details have been saved in system.";
        public const string Message_CurrentAuthorizationNotAdded_Because_Exists = "CurrentAuthorization with provided details already exists in system.";
        public const string Message_CurrentAuthorizationNotAdded = "Failed to add/save the provided currentauthorization details. Please try again.";
        public const string Message_CurrentAuthorizationUpdated = "Provided currentauthorization details have been updated in system.";
        public const string Message_CurrentAuthorizationNotUpdated_Because_NotFound = "Provided currentauthorization details could not be found in system and hence no details have been updated.";
        public const string Message_CurrentAuthorizationNotUpdated = "Failed to update provided currentauthorization details. Please try again.";

        public const string Error_HistoryAuthorizationNotFound = "Failed! to find HistoryAuthorization with supplied Id of: ";
        public const string Message_HistoryAuthorizationDeleted = "Provided historyauthorization details have been deleted in system.";
        public const string Message_HistoryAuthorizationNotDeleted_Because_NotFound = "Provided historyauthorization details could not be found in system and hence no details have been deleted.";
        public const string Message_HistoryAuthorizationNotDeleted = "Failed to delete provided historyauthorization details. Please try again.";
        public const string Message_HistoryAuthorizationAdded = "Provided historyauthorization details have been saved in system.";
        public const string Message_HistoryAuthorizationNotAdded_Because_Exists = "HistoryAuthorization with provided details already exists in system.";
        public const string Message_HistoryAuthorizationNotAdded = "Failed to add/save the provided historyauthorization details. Please try again.";
        public const string Message_HistoryAuthorizationUpdated = "Provided historyauthorization details have been updated in system.";
        public const string Message_HistoryAuthorizationNotUpdated_Because_NotFound = "Provided historyauthorization details could not be found in system and hence no details have been updated.";
        public const string Message_HistoryAuthorizationNotUpdated = "Failed to update provided historyauthorization details. Please try again.";

        #endregion
    }

    public enum Status
    {
        AwaitingApproval = 0,
        Approved = 1,
        Rejected = 2,
        Revoked = 3
    }









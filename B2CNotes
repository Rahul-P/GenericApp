

-------------- Models --------------------

export class ApplicationModel {
    azureApplicationId: string;
    displayName: string;
    id: number;
}



export class AuthorizationModel {
    email: string;
    applicationId: number;
    id: number;
  }
  
  
export class CurrentAuthorizationModel {
    applicationId: number;
    authorizationId: number;
    role: string;
    status: number;
    showStatus: string;
    id: number;
  }
  
export class HistoryAuthorizationModel {
    applicationId: number;
    authorizationId: number;
    currentAuthorizationId: number;
    role: string;
    previousStatus: number;
    id: number;

    showStatus: string;
  }


-------------- Models --------------------



--------------- Application ------------------------


<mat-list>
    <h3 matSubheader class="parent">
      <button mat-raised-button mat-elevation-z8 color="warn"
              matTooltip="Click here to confirm deletion of {{data.displayName}} from system"
              (click)="deleteApplication($event)">
        <mat-icon>delete</mat-icon>
        Confirm Deletion of {{ data.displayName }}
      </button>
    </h3>
</mat-list>
  
  
  table {
    width: inherit;
  }
  
  th.mat-sort-header-sorted {
    color: black;
  }
  
  .mat-row:hover {
    background-color: lightyellow;
  }
  
  .mat-table {
    color: black;
    width: inherit;
  }
  
  .mat-list-item:hover {
    background-color: lightyellow;
  }
  
  
  .parent {
    background-color: #D9EDF7;
  }
  
  .center {
    background-color: yellow;
    display: table; /*shrink to fit width*/
    margin: auto; /*center it*/
  }
  
  .buttoncolor {
    background-color: yellow;
  }
  
  
  
  
      <mat-card>

        <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>
      
        <div class="m-2">
      
          <div class="row">
      
            <div class="col-8 alert alert-info mat-elevation-z8" role="alert">
              <h4 class="alert-heading">
                <mat-icon matListIcon>build</mat-icon>
                Application(s)
              </h4>
              <hr>
              <p class="top">
                Below is the list of all Application(s) that are managed by B2C
              </p>
            </div>
      
            <div class="col-4">
              <button class="buttoncolor" mat-icon-button mat-elevation-z8 color="warn"
                      matTooltip="Click here to Add New Application"
                      (click)="addApplication()">
                <mat-icon>apps plus_one</mat-icon>
              </button>
            </div>      
          </div>
      
          <div >
      
            <div style="text-align:center">      
              <mat-table [dataSource]="applications" matSort class="mat-table mat-elevation-z8">
      
                <!--- Note that these columns can be defined in any order.
                The actual rendered columns are set as a property on the row definition" -->
                <!-- Position Column -->
                <ng-container matColumnDef="id">
                  <mat-header-cell *matHeaderCellDef mat-sort-header> Id </mat-header-cell>
                  <mat-cell *matCellDef="let element"> {{element.id}} </mat-cell>
                </ng-container>

                <ng-container matColumnDef="azureApplicationId">
                  <mat-header-cell *matHeaderCellDef mat-sort-header> Azure Application Id </mat-header-cell>
                  <mat-cell *matCellDef="let element"> {{element.azureApplicationId}} </mat-cell>
                </ng-container>
      
                <!-- Name Column -->
                <ng-container matColumnDef="displayName">
                  <mat-header-cell *matHeaderCellDef mat-sort-header> Display Name </mat-header-cell>
                  <mat-cell *matCellDef="let element"> {{element.displayName}} </mat-cell>
                </ng-container>
      
                <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
                <mat-row style="cursor: pointer" *matRowDef="let row; columns: displayedColumns;" (click)="getApplicationRecord(row.azureApplicationId)">
                </mat-row>
              </mat-table>      
              <mat-paginator [pageSizeOptions]="[5, 10, 20]" showFirstLastButtons></mat-paginator>      
            </div>     
          </div>      
      
          <div class="row">      
            <div *ngIf="rowClicked" style="text-align:center">
              <!-- Div 1-->
              <div class="card text-info rowbackground p-2 mat-elevation-z8">
                <!--Div 2-->
      
                <mat-list>
                  <h3 matSubheader class="parent">
                    <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                            matTooltip="Click here to Edit details for {{currentSelectedApplication.displayName}}"
                            (click)="editApplication(currentSelectedApplication)">
                      <mat-icon>edit</mat-icon>
                      Edit - {{currentSelectedApplication.displayName}}
                    </button>
                  </h3>
      
                  <h3 matSubheader class="parent">
                    <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                            matTooltip="Click here to Delete {{currentSelectedApplication.displayName}} from system"
                            (click)="deleteApplication(currentSelectedApplication)">
                      <mat-icon>delete</mat-icon>
                      Delete - {{currentSelectedApplication.displayName}}
                    </button>
                  </h3>

                  <h3 matSubheader class="parent">
                    <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                    matTooltip="Click here to view authorizations for {{currentSelectedApplication.displayName}}"
                            (click)="viewAuthorization(currentSelectedApplication.id)">
                      <mat-icon>pageview</mat-icon>
                      View Authorization(s) - {{currentSelectedApplication.displayName}}
                    </button>
                  </h3>
      
                  <br />
      
                  <mat-divider></mat-divider>
      
                  <h3 matSubheader>Current Authorization(s) listed for {{currentSelectedApplication.azureApplicationId}}</h3>

                  <!-- <mat-list-item style="cursor: pointer" *ngFor="let authorization of currentSelectedApplication.authorizations"
                                 (click)="FetchAuthorization(authorization)">
                    <mat-icon matListIcon>flight</mat-icon>
                    <h4 matLine>Users Email Address: {{authorization.email}}</h4>
                  </mat-list-item> -->

                </mat-list>
      
              </div> <!--Div 2 Ended-->
            </div> <!--Div 1 Ended-->     
          </div>      
        </div>
      </mat-card>
      
	  
import { Component, OnInit, ViewChild, OnDestroy } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";

import { MatPaginator } from "@angular/material/paginator";
import { MatSort } from "@angular/material/sort";
import { MatTableDataSource } from "@angular/material/table";
import { LoaderService } from "../loader/loader.service";
import { ApplicationModel } from "../models/application";

@Component({
  selector: "application",
  templateUrl: "application.component.html",
  styleUrls: ["application.component.css"]
})
export class Application implements OnInit { 
    constructor(private _dataService: DataService, private _loader: LoaderService, private _router: Router) { }

    public displayedColumns: string[] =
    [
      Constant.ApplicationColumn_Id, 
      Constant.ApplicationColumn_AzureApplicationId, 
      Constant.ApplicationColumn_DisplayName
    ];
    public applications: MatTableDataSource<ApplicationModel>;

    public currentSelectedApplication: ApplicationModel;

    public rowClicked: boolean = Constant.FALSE;
    errorMessage: string = Constant.String_Undefined;
    private _username: string = Constant.String_Undefined;

    @ViewChild(MatSort, { static: Constant.TRUE }) sort: MatSort;
    @ViewChild(MatPaginator, { static: Constant.TRUE }) paginator: MatPaginator;

    async ngOnInit() {

      this._loader.show();   
      await this._dataService.FetchAccessToken();      

      this._username = this._dataService.FetchUserName();

      if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) 
      {
        this._dataService.loadApplications()
        .subscribe(
          {
            next: responseData => {
              this.applications = new MatTableDataSource<ApplicationModel>(responseData);

              this.applications.sort = this.sort;
              this.applications.paginator = this.paginator;
              this._loader.hide();
            },
            error: err => {
              this._loader.hide();
              this.errorMessage = Constant.FetchApplicationsFailed;
              this._router.navigate([Constant.ErrorPageUrl,
                {
                  message: Constant.FetchApplicationsFailed,
                  type: Constant.Error_Type_InternalServiceError
                }]); 
            }
        });
      } else{
        // No user Found - Present Error Page.      
        this._loader.hide();
        this._router.navigate([Constant.ErrorPageUrl,
        {
          message: Constant.PermissionErrorMessageAccess,
          type: Constant.Error_Type_Permission
        }]); 
      }
    }

    public getApplicationRecord(_id: string) {
      this._loader.show(); 
      this._dataService.loadApplication(_id)
        .subscribe(
          {
            next: responseData => {          
              this.currentSelectedApplication = responseData;              
              this.rowClicked = Constant.TRUE;
              this._loader.hide();
            },
            error: err => {
              this._loader.hide();
              this.errorMessage = Constant.FetchApplicationFailed;              
            }
          });   
    }
  
    public editApplication(_applicationToEdit: ApplicationModel) {
      this._dataService.editApplication(_applicationToEdit);
      this._router.navigate([Constant.ApplicationEditUrl]);
    }
  
    public deleteApplication(_applicationToDelete: ApplicationModel) {
      this._dataService.deleteApplication(_applicationToDelete);
      this._router.navigate([Constant.ApplicationDeleteUrl]); 
    }
  
    public addApplication() {
      this._router.navigate([Constant.ApplicationAddUrl]);
    }
  
    public viewAuthorization(_id: number) {
      this._dataService.viewAuthorizationsForApplicationId = _id;
      this._router.navigate([Constant.AuthorizationUrl]);
    }
}







mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  


<mat-card>
    <div *ngIf="errorMessageActive" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessageActive" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="addApplicationForm"
          autocomplete="off" (ngSubmit)="saveNewApplication(addApplicationForm.value)" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Add a new Application</mat-card-title>
  
      <mat-form-field>
        <input matInput #inputApplicationId placeholder="Azure Application Id"
               maxlength="36" id="azureApplicationId" formControlName="azureApplicationId" />
  
        <mat-hint align="center">{{inputApplicationId.value?.length || 0}}/36</mat-hint>
  
        <mat-error *ngIf="hasError('azureApplicationId', 'required')">Azure Application Id is required</mat-error>
        <mat-error *ngIf="hasError('azureApplicationId', 'maxlength')">Only 36 characters are allowed</mat-error>
        <mat-error *ngIf="hasError('azureApplicationId', 'minlength')">At least 36 characters are required</mat-error>
      </mat-form-field>
  
      <mat-form-field>
        <input matInput #inputdisplayname placeholder="Application Display Name"
               maxlength="100" id="displayname" formControlName="displayname" />
  
        <mat-hint align="center">{{inputdisplayname.value?.length || 0}}/100</mat-hint>
  
        <mat-error *ngIf="hasError('displayname', 'required')">Display Name is required</mat-error>
        <mat-error *ngIf="hasError('displayname', 'maxlength')">Only 100 characters are allowed</mat-error>
        <mat-error *ngIf="hasError('displayname', 'minlength')">At least 5 characters are required</mat-error>
      </mat-form-field>
  
  
      <mat-card-actions align="center">
        <button mat-raised-button color="primary"
                matTooltip="Click here to Save details for {{inputApplicationId.value}}"
                type="submit" [disabled]="!addApplicationForm.valid || isSaveDisabled()">
          <mat-icon>save</mat-icon>
          Save Details
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelSave()"
                matTooltip="Click here to Cancel" [disabled]="isSaveDisabled()">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
      </mat-card-actions>
  
      <mat-card-actions align="center">
        <button type="button" mat-raised-button color="accent" (click)="backToApplications()"
                matTooltip="Click here to go back to applications page">
          <mat-icon>arrow_back</mat-icon>
          Back to Application(s)
        </button>
      </mat-card-actions>
    </form>
  </mat-card>
  
  
  
 
 
 import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { ApplicationModel } from "../models/application";

@Component({
  selector: "applicationadd",
  templateUrl: "applicationadd.component.html",
  styleUrls: ["applicationadd.component.css"]
})
export class ApplicationAdd implements OnInit { 

    addApplicationForm: FormGroup;
    errorMessageActive: boolean = Constant.FALSE;
    successMessageActive: boolean = Constant.FALSE;

    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;
    isSaveButtonDisabled: boolean;

    private _username: string = Constant.String_Undefined;

    constructor(private _dataService: DataService, private _router: Router, 
        private _loader: LoaderService, fb: FormBuilder,
        private _changeDetector: ChangeDetectorRef) {
    
        this.addApplicationForm = fb.group({
          hideRequired: Constant.FALSE,
          floatLabel: Constant.FloatLabel_AUTO
        });
    
        this.addApplicationForm = new FormGroup(
          {
            azureApplicationId: new FormControl({ value: Constant.String_Undefined, disabled: Constant.FALSE },
              [Validators.required, Validators.maxLength(Constant.AzureApplicationIdMaxLength),
                Validators.minLength(Constant.AzureApplicationIdMaxLength)]),
            displayname: new FormControl({ value: Constant.String_Undefined, disabled: Constant.FALSE },
              [Validators.required, Validators.maxLength(Constant.ApplicationDisplayNameMaxLength), 
                Validators.minLength(Constant.ApplicationDisplayNameMinLength)])
          });
    }

    async ngOnInit() {
        this._loader.show();   
        await this._dataService.FetchAccessToken();   
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.isSaveButtonDisabled = Constant.FALSE;
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]); 
        }
    }

    ngAfterContentChecked(): void {
        this._changeDetector.detectChanges();
    }
    
    cancelSave() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToApplications() {
        this._router.navigate([Constant.ApplicationUrl]);
    }
    
    isSaveDisabled() {
        return this.isSaveButtonDisabled;
    }

    public saveNewApplication = (_passedApplication) => {
        if (this.addApplicationForm.valid) {
          this.saveNewApplicationViaApi(_passedApplication);
        }
    }
    
    private saveNewApplicationViaApi(_application: ApplicationModel) {
        this._loader.show(); 
        this._dataService.addApplication(_application)
          .subscribe(
            {
              next: response => {
                this.isSaveButtonDisabled = Constant.TRUE;
                if (response !== Constant.Undefined) {
                  this.successMessage = Constant.Save_SuccessfulForApplication;
                  this.successMessageActive = Constant.TRUE;
                  this.errorMessageActive = Constant.FALSE;
    
                  this._loader.hide(); 
                }
                else {
                  this.errorMessage = Constant.Error_FailedToSaveApplication;
                  this.errorMessageActive = Constant.TRUE;
                  this.successMessageActive = Constant.FALSE;
    
                  this._loader.hide(); 
                }
    
              },
              error: err => {
                this.errorMessage = Constant.Error_FailedToSaveApplication;
                this.errorMessageActive = Constant.TRUE;
                this.successMessageActive = Constant.FALSE;
    
                this._loader.hide();
            }
        });
      }
    
    public hasError = (controlName: string, errorName: string) => {
        return this.addApplicationForm.controls[controlName].hasError(errorName);
    }
}



mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
  
  
  
  
<mat-card>
    <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessage" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="deleteApplicationForm"
          autocomplete="off" (ngSubmit)="deleteApplication()" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Delete Application {{inputdisplayname.value}}</mat-card-title>
  
      <mat-card-content>
        <mat-form-field>
          <input matInput #inputApplicationId placeholder="Azure Application Id"
                 maxlength="36" id="azureApplicationId" formControlName="azureApplicationId" />
  
          <mat-hint align="center">{{inputApplicationId.value?.length || 0}}/36</mat-hint>
  
          <mat-error *ngIf="hasError('azureApplicationId', 'required')">Azure Application Id is required</mat-error>
          <mat-error *ngIf="hasError('azureApplicationId', 'maxlength')">Only 36 characters are allowed</mat-error>
          <mat-error *ngIf="hasError('azureApplicationId', 'minlength')">At least 36 characters are required</mat-error>
        </mat-form-field>
  
        <mat-form-field>
          <input matInput #inputdisplayname placeholder="Application Name"
                 maxlength="100" id="displayname" formControlName="displayname" />
  
          <mat-hint align="center">{{inputdisplayname.value?.length || 0}}/30</mat-hint>
  
          <mat-error *ngIf="hasError('displayname', 'required')">Application Display name is required</mat-error>
          <mat-error *ngIf="hasError('displayname', 'maxlength')">Only 100 characters are allowed</mat-error>
        </mat-form-field>
      </mat-card-content>
  
      <mat-card-actions align="center">
        <button mat-raised-button color="primary"
                matTooltip="Click here to delete details for {{inputdisplayname.value}}"
                type="submit" [disabled]="isDeleteDisabled()">
          <mat-icon>delete</mat-icon>
          Delete {{inputdisplayname.value}}
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelDelete()"
                matTooltip="Click here to cancel and return to settings" [disabled]="isDeleteDisabled()">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
      </mat-card-actions>
  
  
      <mat-card-actions align="center">
        <button type="button" mat-raised-button color="accent" (click)="backToApplications()"
                matTooltip="Click here to go back to Applications page">
          <mat-icon>arrow_back</mat-icon>
          Back to Applications
        </button>
      </mat-card-actions>
    </form>
</mat-card>
  
  
  
  
  
  import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef, Inject } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { MatBottomSheet, MatBottomSheetRef, MAT_BOTTOM_SHEET_DATA } from "@angular/material/bottom-sheet";
import { ApplicationModel } from "../models/application";

@Component({
  selector: "applicationdelete",
  templateUrl: "applicationdelete.component.html",
  styleUrls: ["applicationdelete.component.css"]
})
export class ApplicationDelete implements OnInit { 

    deleteApplicationForm: FormGroup;
    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;
    private application: ApplicationModel;
    isDeleteButtonDisabled: boolean;
    private _username: string = Constant.String_Undefined;

    constructor(private _dataService: DataService, private _router: Router, 
        private _loader: LoaderService, fb: FormBuilder, private _bottomSheet: MatBottomSheet) {
        if (this._dataService.currentApplicationToDelete !== Constant.NULL && this._dataService.currentApplicationToDelete !== Constant.Undefined) {
          this.deleteApplicationForm = fb.group({
            hideRequired: Constant.FALSE,
            floatLabel: Constant.FloatLabel_AUTO
          });
    
          this.deleteApplicationForm = new FormGroup(
            {
                azureApplicationId: new FormControl({ value: this._dataService.currentApplicationToDelete.azureApplicationId, disabled: Constant.TRUE },
                    [Validators.required, Validators.maxLength(Constant.AzureApplicationIdMaxLength)]),
                displayname: new FormControl({ value: this._dataService.currentApplicationToDelete.displayName, disabled: Constant.TRUE },
                    [Validators.required, Validators.maxLength(Constant.ApplicationDisplayNameMaxLength),
                        Validators.minLength(Constant.ApplicationDisplayNameMinLength)])
            });
        }
        else {
          _router.navigate([Constant.ApplicationUrl]);
        }  
    }

    async ngOnInit() {
        this._loader.show();  
        await this._dataService.FetchAccessToken();    
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.application = this._dataService.currentApplicationToDelete;
          this._dataService.deleteApplicationBottomSheetConfirmed(Constant.FALSE);
          this.isDeleteButtonDisabled = Constant.FALSE;
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]);
        }
    }

    cancelDelete() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToApplications() {
        this._router.navigate([Constant.ApplicationUrl]);
    }
    
    isDeleteDisabled() {
        return this.isDeleteButtonDisabled;
    }

    deleteApplication() {
        const _bottomSheetRef = this._bottomSheet.open(ApplicationDeleteBottomSheet, {
          data: { displayName: [this.application.displayName] }
        });
    
        _bottomSheetRef
          .afterDismissed()
          .subscribe(
            {
              next: (responseData) => {
                if (this._dataService.deleteApplicationBottomSheetClicked) {
    
                  this._loader.show();
    
                  this._dataService.deleteChoosenApplication(this.application)
                    .subscribe(
                      {
                        next: responseData => {
                          this.isDeleteButtonDisabled = Constant.TRUE;
                          this.successMessage = responseData;
    
                          this._loader.hide();
                        },
                        error: err => {
                          this.isDeleteButtonDisabled = Constant.FALSE;
                          this.errorMessage = Constant.DeleteApplicationFailed;
    
                          this._loader.hide();
                        }
                      });
                }
              },
              error: (err) => {
                // Nothing here.
              }
            }); 
    }

    public hasError = (controlName: string, errorName: string) => {
        return this.deleteApplicationForm.controls[controlName].hasError(errorName);
    }
}

@Component({
    selector: 'application-delete-bottom-sheet-dialog',
    templateUrl: 'application-delete-bottom-sheet.html',
  })
  export class ApplicationDeleteBottomSheet {
    constructor(private _bottomSheetRef: MatBottomSheetRef<ApplicationDeleteBottomSheet>,
      private _dataServiceApplicationBottomSheet: DataService,
      @Inject(MAT_BOTTOM_SHEET_DATA) public data: any) { }
  
    openLink(event: MouseEvent): void {
      this._bottomSheetRef.dismiss();
      event.preventDefault();
    }
  
    deleteApplication(event: MouseEvent) {
      this._dataServiceApplicationBottomSheet
        .deleteApplicationBottomSheetConfirmed(Constant.TRUE);
  
      this._bottomSheetRef.dismiss();
      event.preventDefault();
    }
}



mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
  
<mat-card>
    <div *ngIf="errorMessageActive" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessageActive" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="updateApplicationForm"
          autocomplete="off" (ngSubmit)="saveEditOfApplication(updateApplicationForm.value)" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Update Application</mat-card-title>
  
      <mat-card-content>
  
        <mat-form-field>
          <input matInput #inputazureApplicationId placeholder="Azure Application Id"
                 maxlength="36" id="azureApplicationId" formControlName="azureApplicationId" />
  
          <mat-hint align="center">{{inputazureApplicationId.value?.length || 0}}/36</mat-hint>
  
          <mat-error *ngIf="hasError('azureApplicationId', 'required')">Azure Application Id is required</mat-error>
        <mat-error *ngIf="hasError('azureApplicationId', 'maxlength')">Only 36 characters are allowed</mat-error>
        <mat-error *ngIf="hasError('azureApplicationId', 'minlength')">At least 36 characters are required</mat-error>
        </mat-form-field>
  
        <mat-form-field>
          <input matInput #inputdisplayName placeholder="Display Name"
                 maxlength="100" id="displayName" formControlName="displayName" />
  
          <mat-hint align="center">{{inputdisplayName.value?.length || 0}}/100</mat-hint>
  
          <mat-error *ngIf="hasError('displayName', 'required')">Display Name is required</mat-error>
        <mat-error *ngIf="hasError('displayName', 'maxlength')">Only 100 characters are allowed</mat-error>
        <mat-error *ngIf="hasError('displayName', 'minlength')">At least 5 characters are required</mat-error>
        </mat-form-field>  
  
      </mat-card-content>
  
  
      <mat-card-actions align="center">
  
        <button mat-raised-button color="primary"
                matTooltip="Click here to Save details for {{inputazureApplicationId.value}}"
                type="submit" [disabled]="!updateApplicationForm.valid || isSaveDisabled(updateApplicationForm.value)">
          <mat-icon>save</mat-icon>
          Update Application
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelUpdate()"
                matTooltip="Click here to Cancel" [disabled]="isSaveDisabled(undefined)">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
  
  
      </mat-card-actions>
  
      <mat-card-actions align="center">
        <button class="button" mat-raised-button mat-elevation-z8 color="accent"
                matTooltip="Click here to go back to applications page"
                type="button" (click)="backToApplications()">
          <mat-icon>arrow_back</mat-icon>
          Back to Applications
        </button>
      </mat-card-actions>
  
    </form>
  </mat-card>
  
  
  
  import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { ApplicationModel } from "../models/application";

@Component({
  selector: "applicationedit",
  templateUrl: "applicationedit.component.html",
  styleUrls: ["applicationedit.component.css"]
})
export class ApplicationEdit implements OnInit { 

    updateApplicationForm: FormGroup;
    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;

    isSaveButtonDisabled: boolean;

    errorMessageActive: boolean = Constant.FALSE;
    successMessageActive: boolean = Constant.FALSE;

    public _username: string = Constant.String_Undefined;
    private updatedApplication: ApplicationModel = new ApplicationModel();

    constructor(private _dataService: DataService, private _router: Router, private _loader: LoaderService, 
        fb: FormBuilder, private _changeDetector: ChangeDetectorRef) {
        if (this._dataService.currentApplicationToEdit !== Constant.NULL && this._dataService.currentApplicationToEdit !== Constant.Undefined) {
    
          this.updateApplicationForm = fb.group({
            hideRequired: Constant.FALSE,
            floatLabel: Constant.FloatLabel_AUTO
          });
    
          this.updateApplicationForm = new FormGroup(
            {
                azureApplicationId: new FormControl({ value: this._dataService.currentApplicationToEdit.azureApplicationId, disabled: Constant.TRUE },
                    [Validators.required, Validators.maxLength(Constant.AzureApplicationIdMaxLength)]),
                displayName: new FormControl({ value: this._dataService.currentApplicationToEdit.displayName, disabled: Constant.FALSE },
                    [Validators.required, Validators.maxLength(Constant.ApplicationDisplayNameMaxLength),
                    Validators.minLength(Constant.ApplicationDisplayNameMinLength)])
            });
        }
        else {
          _router.navigate([Constant.ApplicationUrl]);
        }    
    }


    async ngOnInit() {
        this._loader.show();
        await this._dataService.FetchAccessToken();   
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.isSaveButtonDisabled = Constant.TRUE;
          this.mapApplicationModels(this._dataService.currentApplicationToEdit);
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]);
        }
    }


    ngAfterContentChecked(): void {
        this._changeDetector.detectChanges();
    }
    
    cancelUpdate() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToApplications() {
        this._router.navigate([Constant.ApplicationUrl]);
    }


    isSaveDisabled(_passedFormApplication: ApplicationModel) {
        if (_passedFormApplication !== Constant.Undefined) {
          if (this.updatedApplication.displayName !== _passedFormApplication.displayName) {
            this.isSaveButtonDisabled = Constant.FALSE;
            this.errorMessageActive = Constant.FALSE;
            this.successMessageActive = Constant.FALSE;
          }
          else {
            this.isSaveButtonDisabled = Constant.TRUE;
          }
        }
        return this.isSaveButtonDisabled;
    }
    
    saveEditOfApplication(_passedFormApplication: ApplicationModel) {
    
        // #region Set the Disabled Column Name before we Fire Update request    
        _passedFormApplication.azureApplicationId = this._dataService.currentApplicationToEdit.azureApplicationId;
        // #endregion
    
        this._loader.show();
    
        this._dataService.updateApplication(_passedFormApplication)
          .subscribe(
            {
              next: responseText => {
                this.mapApplicationModels(_passedFormApplication);
                this.isSaveButtonDisabled = Constant.TRUE;
    
                this.successMessage = responseText;
                this.successMessageActive = Constant.TRUE;
                this.errorMessageActive = Constant.FALSE;
    
                this._loader.hide();
              },
              error: err => {
                this.errorMessage = Constant.Error_FailedToUpdateApplication;
                this.errorMessageActive = Constant.TRUE;
    
                this._loader.hide();
              }
            });
    }
    
    mapApplicationModels(_passedFormApplication: ApplicationModel) {
        this.updatedApplication.displayName = _passedFormApplication.displayName;
    }
    
    public hasError = (controlName: string, errorName: string) => {
        return this.updateApplicationForm.controls[controlName].hasError(errorName);
    }
}

  
  



---------------- Application -----------------------------




---------------- Authorization -----------------------------


<mat-list>
    <h3 matSubheader class="parent">
      <button mat-raised-button mat-elevation-z8 color="warn"
              matTooltip="Click here to confirm deletion of {{data.email}} for Application Id {{ data.applicationId }} from system"
              (click)="deleteAuthorization($event)">
        <mat-icon>delete</mat-icon>
        Confirm Deletion of {{ data.email }} for Application Id {{ data.applicationId }}
      </button>
    </h3>
</mat-list>
  
  
  
 table {
    width: inherit;
  }
  
  th.mat-sort-header-sorted {
    color: black;
  }
  
  .mat-row:hover {
    background-color: lightyellow;
  }
  
  .mat-table {
    color: black;
    width: inherit;
  }
  
  .mat-list-item:hover {
    background-color: lightyellow;
  }
  
  
  .parent {
    background-color: #D9EDF7;
  }
  
  .center {
    background-color: yellow;
    display: table; /*shrink to fit width*/
    margin: auto; /*center it*/
  }
  
  .buttoncolor {
    background-color: yellow;
  }
  
  
  <mat-card>

    <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>
  
    <div class="m-2">
  
      <div class="row">
  
        <div class="col-8 alert alert-info mat-elevation-z8" role="alert">
          <h4 class="alert-heading">
            <mat-icon matListIcon>build</mat-icon>
            Authorization(s)
          </h4>
          <hr>
          <p class="top">
            Below is the list of all Authorization(s) for selected Authorization.
          </p>
        </div>
  
        <div class="col-4">
          <button class="buttoncolor" mat-icon-button mat-elevation-z8 color="warn"
                  matTooltip="Click here to Add New Authorization"
                  (click)="addAuthorization()">
            <mat-icon>apps plus_one</mat-icon>
          </button>
        </div>      
      </div>
  
      <div >
  
        <div style="text-align:center">      
          <mat-table [dataSource]="authorizations" matSort class="mat-table mat-elevation-z8">
  
            <!--- Note that these columns can be defined in any order.
            The actual rendered columns are set as a property on the row definition" -->
            <!-- Position Column -->

            <ng-container matColumnDef="id">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Authorization Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.id}} </mat-cell>
            </ng-container>            
  
            <!-- Name Column -->
            <ng-container matColumnDef="email">
              <mat-header-cell *matHeaderCellDef mat-sort-header> Email Address </mat-header-cell>
              <mat-cell *matCellDef="let element"> {{element.email}} </mat-cell>
            </ng-container>

            <ng-container matColumnDef="applicationId">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Application Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.applicationId}} </mat-cell>
            </ng-container>
  
            <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
            <mat-row style="cursor: pointer" *matRowDef="let row; columns: displayedColumns;" 
                (click)="getAuthorizationRecord(row.email, row.applicationId)">
            </mat-row>
          </mat-table>      
          <mat-paginator [pageSizeOptions]="[5, 10, 20]" showFirstLastButtons></mat-paginator>      
        </div>     
      </div>      
  
      <div class="row">      
        <div *ngIf="rowClicked" style="text-align:center">
          <!-- Div 1-->
          <div class="card text-info rowbackground p-2 mat-elevation-z8">
            <!--Div 2-->
  
            <mat-list>
              <h3 matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to Edit details for {{currentSelectedAuthorization.email}}"
                        (click)="editAuthorization(currentSelectedAuthorization)">
                  <mat-icon>edit</mat-icon>
                  Edit - {{currentSelectedAuthorization.email}}
                </button>
              </h3>
  
              <h3 matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to Delete {{currentSelectedAuthorization.email}} from system"
                        (click)="deleteAuthorization(currentSelectedAuthorization)">
                  <mat-icon>delete</mat-icon>
                  Delete - {{currentSelectedAuthorization.email}}
                </button>
              </h3>
  
              <br />
  
              <div matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to Add New Authorization for {{currentSelectedAuthorization.applicationId}}"
                        (click)="addAuthorization(currentSelectedAuthorization.applicationId)">
                  <mat-icon>note_add</mat-icon>
                  Add New Authorization
                  <mat-icon>plus_one</mat-icon>
                </button>
              </div>              
  
              <br />

              <div matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to View Current Authorization for Application Id of: {{currentSelectedAuthorization.applicationId}}
                                    Authorization Id of: and {{currentSelectedAuthorization.id}}"
                        (click)="viewCurrentAuthorization(currentSelectedAuthorization.id, currentSelectedAuthorization.applicationId)">
                  <mat-icon>pageview</mat-icon>
                  View - Current Authorizations for {{currentSelectedAuthorization.email}}
                </button>
              </div>
  
              <mat-divider></mat-divider>             

            </mat-list>
  
          </div> <!--Div 2 Ended-->
        </div> <!--Div 1 Ended-->   
      </div>      
    </div>

    <mat-card-actions align="center">
        <button class="button" mat-raised-button mat-elevation-z8 color="accent"
                matTooltip="Click here to go back to Applications page"
                type="button" (click)="backToApplications()">
          <mat-icon>arrow_back</mat-icon>
          Back to Applications
        </button>
    </mat-card-actions>
  </mat-card>
  
  
  
  
  
  // viewAuthorizationForApplicationId

import { Component, OnInit, ViewChild, OnDestroy } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";

import { MatPaginator } from "@angular/material/paginator";
import { MatSort } from "@angular/material/sort";
import { MatTableDataSource } from "@angular/material/table";
import { LoaderService } from "../loader/loader.service";
import { AuthorizationModel } from "../models/authorization";

@Component({
  selector: "authorization",
  templateUrl: "authorization.component.html",
  styleUrls: ["authorization.component.css"]
})
export class Authorization implements OnInit { 

    constructor(private _dataService: DataService, private _loader: LoaderService, private _router: Router) { }

    public displayedColumns: string[] =
    [
      Constant.AuthorizationColumn_Id, 
      Constant.AuthorizationColumn_email, 
      Constant.AuthorizationColumn_applicationId
    ];
    public authorizations: MatTableDataSource<AuthorizationModel>;

    public currentSelectedAuthorization: AuthorizationModel;

    public rowClicked: boolean = Constant.FALSE;
    errorMessage: string = Constant.String_Undefined;
    private _username: string = Constant.String_Undefined;

    @ViewChild(MatSort, { static: Constant.TRUE }) sort: MatSort;
    @ViewChild(MatPaginator, { static: Constant.TRUE }) paginator: MatPaginator;

    async ngOnInit() {

        this._loader.show();   
        await this._dataService.FetchAccessToken();      
  
        this._username = this._dataService.FetchUserName();
  
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) 
        {
            if (this._dataService.viewAuthorizationsForApplicationId !== Constant.NULL && 
                this._dataService.viewAuthorizationsForApplicationId !== Constant.Undefined)
            {
                this._dataService.loadAuthorizations()
                .subscribe(
                {
                    next: responseData => {
                    this.authorizations = new MatTableDataSource<AuthorizationModel>(responseData);
  
                    this.authorizations.sort = this.sort;
                    this.authorizations.paginator = this.paginator;
                    this._loader.hide();
                },
                error: err => 
                {
                    this._loader.hide();
                    this.errorMessage = Constant.FetchAuthorizationsFailed;
                    this._router.navigate([Constant.ErrorPageUrl,
                    {
                        message: Constant.FetchAuthorizationsFailed,
                        type: Constant.Error_Type_InternalServiceError
                    }]); 
                }});
            }
            else
            {
                this._router.navigate([Constant.ApplicationUrl]);
            }
        } 
        else
        {
          // No user Found - Present Error Page.      
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]); 
        }
    }

    public getAuthorizationRecord(_email: string, _applicationId: number) {
        this._loader.show(); 
        this._dataService.loadAuthorization(_email, _applicationId)
          .subscribe(
            {
              next: responseData => {          
                this.currentSelectedAuthorization = responseData;               
                this.rowClicked = Constant.TRUE;
                this._loader.hide();
              },
              error: err => {
                this._loader.hide();
                this.errorMessage = Constant.FetchAuthorizationFailed;              
              }
            });   
    }

    backToApplications() {
        this._router.navigate([Constant.ApplicationUrl]);
    }

    public editAuthorization(_authorizationToEdit: AuthorizationModel) {
        this._dataService.editAuthorization(_authorizationToEdit);
        this._router.navigate([Constant.AuthorizationEditUrl]);
    }
    
      public deleteAuthorization(_authorizationToDelete: AuthorizationModel) {
        this._dataService.deleteAuthorization(_authorizationToDelete);
        this._router.navigate([Constant.AuthorizationDeleteUrl]); 
    }
    
      public addAuthorization() {
        this._router.navigate([Constant.AuthorizationAddUrl]);
    }
    
      public viewCurrentAuthorization(_authorizationId: number, _applicationId: number) {
        this._dataService.viewCurrentAuthorizationForApplicationId = _applicationId;
        this._dataService.viewCurrentAuthorizationForAuthorizationId = _authorizationId;
        this._router.navigate([Constant.CurrentAuthorizationUrl]);
    }
}




mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
  

<mat-card>
    <div *ngIf="errorMessageActive" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessageActive" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="addAuthorizationForm"
          autocomplete="off" (ngSubmit)="saveNewAuthorization(addAuthorizationForm.value)" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Add a new Authorization</mat-card-title>
  
      <mat-form-field>
        <input matInput #inputapplicationid placeholder="Application Id"
               id="applicationid" formControlName="applicationid" />
      </mat-form-field>

      <mat-form-field>
        <input matInput #inputemail placeholder="Email"
               maxlength="500" id="email" formControlName="email" />
  
        <mat-hint align="center">{{inputemail.value?.length || 0}}/500</mat-hint>
  
        <mat-error *ngIf="hasError('email', 'required')">Email Address is required</mat-error>
        <mat-error *ngIf="hasError('email', 'maxlength')">Only 500 characters are allowed</mat-error>
        <mat-error *ngIf="hasError('email', 'minlength')">At least 5 characters are required</mat-error>
      </mat-form-field>     
  
  
      <mat-card-actions align="center">
        <button mat-raised-button color="primary"
                matTooltip="Click here to Save details for {{inputemail.value}}"
                type="submit" [disabled]="!addAuthorizationForm.valid || isSaveDisabled()">
          <mat-icon>save</mat-icon>
          Save Details
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelSave()"
                matTooltip="Click here to Cancel" [disabled]="isSaveDisabled()">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
      </mat-card-actions>
  
      <mat-card-actions align="center">
        <button type="button" mat-raised-button color="accent" (click)="backToAuthorizations()"
                matTooltip="Click here to go back to Authorizations page">
          <mat-icon>arrow_back</mat-icon>
          Back to Authorization(s)
        </button>
      </mat-card-actions>
    </form>
</mat-card>
  
  
  
  import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { AuthorizationModel } from "../models/authorization";

@Component({
  selector: "authorizationadd",
  templateUrl: "authorizationadd.component.html",
  styleUrls: ["authorizationadd.component.css"]
})
export class AuthorizationAdd implements OnInit { 

    addAuthorizationForm: FormGroup;
    errorMessageActive: boolean = Constant.FALSE;
    successMessageActive: boolean = Constant.FALSE;

    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;
    isSaveButtonDisabled: boolean;

    private _username: string = Constant.String_Undefined;

    constructor(private _dataService: DataService, private _router: Router, 
        private _loader: LoaderService, fb: FormBuilder,
        private _changeDetector: ChangeDetectorRef) {
    
        this.addAuthorizationForm = fb.group({
          hideRequired: Constant.FALSE,
          floatLabel: Constant.FloatLabel_AUTO
        });
    
        if (this._dataService.viewAuthorizationsForApplicationId !== Constant.NULL && 
            this._dataService.viewAuthorizationsForApplicationId !== Constant.Undefined){
            this.addAuthorizationForm = new FormGroup(
            {
                applicationid: new FormControl({ value: this._dataService.viewAuthorizationsForApplicationId, disabled: Constant.TRUE },
                    [Validators.required, Validators.maxLength(Constant.AzureApplicationIdMaxLength),
                        Validators.minLength(Constant.AzureApplicationIdMaxLength)]),
                email: new FormControl({ value: Constant.String_Undefined, disabled: Constant.FALSE },
                    [Validators.required, Validators.maxLength(Constant.AuthorizationEmailMaxLength), 
                        Validators.minLength(Constant.AuthorizationEmailMinLength)])
          });
        } else{
            this._router.navigate([Constant.ApplicationUrl]);
        }
    }

    async ngOnInit() {
        this._loader.show();   
        await this._dataService.FetchAccessToken();   
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.isSaveButtonDisabled = Constant.FALSE;
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]); 
        }
    }

    ngAfterContentChecked(): void {
        this._changeDetector.detectChanges();
    }
    
    cancelSave() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToAuthorizations() {
        this._router.navigate([Constant.AuthorizationUrl]);
    }
    
    isSaveDisabled() {
        return this.isSaveButtonDisabled;
    }

    public saveNewAuthorization = (_passedAuthorization) => {
        if (this.addAuthorizationForm.valid) {
          this.saveNewAuthorizationViaApi(_passedAuthorization);
        }
    }
    
    private saveNewAuthorizationViaApi(_authorization: AuthorizationModel) {
        this._loader.show(); 

        _authorization.applicationId = this._dataService.viewAuthorizationsForApplicationId;
        
        this._dataService.addAuthorization(_authorization)
          .subscribe(
            {
              next: response => {
                this.isSaveButtonDisabled = Constant.TRUE;
                if (response !== Constant.Undefined) {
                  this.successMessage = Constant.Save_SuccessfulForAuthorization;
                  this.successMessageActive = Constant.TRUE;
                  this.errorMessageActive = Constant.FALSE;
    
                  this._loader.hide(); 
                }
                else {
                  this.errorMessage = Constant.Error_FailedToSaveAuthorization;
                  this.errorMessageActive = Constant.TRUE;
                  this.successMessageActive = Constant.FALSE;
    
                  this._loader.hide(); 
                }    
              },
              error: err => {
                this.errorMessage = Constant.Error_FailedToSaveAuthorization;
                this.errorMessageActive = Constant.TRUE;
                this.successMessageActive = Constant.FALSE;
    
                this._loader.hide();
            }
        });
      }
    
    public hasError = (controlName: string, errorName: string) => {
        return this.addAuthorizationForm.controls[controlName].hasError(errorName);
    }
}



mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
  
<mat-card>
    <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessage" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="deleteAuthorizationForm"
          autocomplete="off" (ngSubmit)="deleteAuthorization()" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Delete Authorization {{inputemail.value}}</mat-card-title>
  
      <mat-card-content>
        <mat-form-field>
          <input matInput #inputid placeholder="Authorization Id"
                 id="id" formControlName="id" />
        </mat-form-field>
  
        <mat-form-field>
          <input matInput #inputapplicationid placeholder="Application Id"
                 id="applicationid" formControlName="applicationid" />
        </mat-form-field>

        <mat-form-field>
            <input matInput #inputemail placeholder="Email"
                   id="email" formControlName="email" />
          </mat-form-field>
      </mat-card-content>
  
      <mat-card-actions align="center">
        <button mat-raised-button color="primary"
                matTooltip="Click here to delete details for {{inputemail.value}} for Application Id of {{inputapplicationid.value}}"
                type="submit" [disabled]="isDeleteDisabled()">
          <mat-icon>delete</mat-icon>
          Delete {{inputemail.value}} for Application Id of {{inputapplicationid.value}}
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelDelete()"
                matTooltip="Click here to cancel and return to settings" [disabled]="isDeleteDisabled()">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
      </mat-card-actions>
  
  
      <mat-card-actions align="center">
        <button type="button" mat-raised-button color="accent" (click)="backToAuthorizations()"
                matTooltip="Click here to go back to Authorizations page">
          <mat-icon>arrow_back</mat-icon>
          Back to Authorizations
        </button>
      </mat-card-actions>
    </form>
</mat-card>
  
  
  import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef, Inject } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { MatBottomSheet, MatBottomSheetRef, MAT_BOTTOM_SHEET_DATA } from "@angular/material/bottom-sheet";
import { AuthorizationModel } from "../models/authorization";

@Component({
  selector: "authorizationdelete",
  templateUrl: "authorizationdelete.component.html",
  styleUrls: ["authorizationdelete.component.css"]
})
export class AuthorizationDelete implements OnInit { 

    deleteAuthorizationForm: FormGroup;
    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;
    private authorization: AuthorizationModel;
    isDeleteButtonDisabled: boolean;
    private _username: string = Constant.String_Undefined;

    constructor(private _dataService: DataService, private _router: Router, 
        private _loader: LoaderService, fb: FormBuilder, private _bottomSheet: MatBottomSheet) {
        if (this._dataService.currentAuthorizationToDelete !== Constant.NULL && this._dataService.currentAuthorizationToDelete !== Constant.Undefined) {
          this.deleteAuthorizationForm = fb.group({
            hideRequired: Constant.FALSE,
            floatLabel: Constant.FloatLabel_AUTO
          });
    
          this.deleteAuthorizationForm = new FormGroup(
            {
                id: new FormControl({ value: this._dataService.currentAuthorizationToDelete.id, disabled: Constant.TRUE }),
                applicationid: new FormControl({ value: this._dataService.currentAuthorizationToDelete.applicationId, disabled: Constant.TRUE }),
                email: new FormControl({ value: this._dataService.currentAuthorizationToDelete.email, disabled: Constant.TRUE })
            });
        }
        else {
          _router.navigate([Constant.AuthorizationUrl]);
        }  
    }

    async ngOnInit() {
        this._loader.show();  
        await this._dataService.FetchAccessToken();    
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.authorization = this._dataService.currentAuthorizationToDelete;
          this._dataService.deleteAuthorizationBottomSheetConfirmed(Constant.FALSE);
          this.isDeleteButtonDisabled = Constant.FALSE;
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]);
        }
    }

    cancelDelete() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToAuthorizations() {
        this._router.navigate([Constant.AuthorizationUrl]);
    }
    
    isDeleteDisabled() {
        return this.isDeleteButtonDisabled;
    }

    deleteAuthorization() {
        const _bottomSheetRef = this._bottomSheet.open(AuthorizationDeleteBottomSheet, {
          data: 
          { 
              email: [this.authorization.email], 
              applicationid: [this.authorization.applicationId] 
            }
        });
    
        _bottomSheetRef
          .afterDismissed()
          .subscribe(
            {
              next: (responseData) => {
                if (this._dataService.deleteAuthorizationBottomSheetClicked) {
    
                  this._loader.show();
    
                  this._dataService.deleteChoosenAuthorization(this.authorization )
                    .subscribe(
                      {
                        next: responseData => {
                          this.isDeleteButtonDisabled = Constant.TRUE;
                          this.successMessage = responseData;
    
                          this._loader.hide();
                        },
                        error: err => {
                          this.isDeleteButtonDisabled = Constant.FALSE;
                          this.errorMessage = Constant.DeleteAuthorizationFailed;
    
                          this._loader.hide();
                        }
                      });
                }
              },
              error: (err) => {
                // Nothing here.
              }
            }); 
    }

    public hasError = (controlName: string, errorName: string) => {
        return this.deleteAuthorizationForm.controls[controlName].hasError(errorName);
    }
}

@Component({
    selector: 'authorization-delete-bottom-sheet-dialog',
    templateUrl: 'authorization-delete-bottom-sheet.html',
  })
  export class AuthorizationDeleteBottomSheet {
    constructor(private _bottomSheetRef: MatBottomSheetRef<AuthorizationDeleteBottomSheet>,
      private _dataServiceAuthorizationBottomSheet: DataService,
      @Inject(MAT_BOTTOM_SHEET_DATA) public data: any) { }
  
    openLink(event: MouseEvent): void {
      this._bottomSheetRef.dismiss();
      event.preventDefault();
    }
  
    deleteAuthorization(event: MouseEvent) {
      this._dataServiceAuthorizationBottomSheet
        .deleteAuthorizationBottomSheetConfirmed(Constant.TRUE);
  
      this._bottomSheetRef.dismiss();
      event.preventDefault();
    }
}




mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
  
<mat-card>
    <div *ngIf="errorMessageActive" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessageActive" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="updateAuthorizationForm"
          autocomplete="off" (ngSubmit)="saveEditOfAuthorization(updateAuthorizationForm.value)" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Update Authorization</mat-card-title>
  
      <mat-card-content>
  
        <mat-form-field>
          <input matInput #inputid placeholder="Id" id="id" formControlName="id" />
        </mat-form-field>

        <mat-form-field>
            <input matInput #inputapplicationid placeholder="Application Id" 
                id="applicationid" formControlName="applicationid" />
        </mat-form-field>
  
        <mat-form-field>
            <input matInput #inputemail placeholder="Email"
                 maxlength="500" id="email" formControlName="email" />
  
            <mat-hint align="center">{{inputemail.value?.length || 0}}/100</mat-hint>
  
            <mat-error *ngIf="hasError('email', 'required')">Email Address is required</mat-error>
            <mat-error *ngIf="hasError('email', 'maxlength')">Only 500 characters are allowed</mat-error>
            <mat-error *ngIf="hasError('email', 'minlength')">At least 5 characters are required</mat-error>
        </mat-form-field>          
  
      </mat-card-content>
  
  
      <mat-card-actions align="center">
  
        <button mat-raised-button color="primary"
                matTooltip="Click here to Save details for {{inputemail.value}}"
                type="submit" [disabled]="!updateAuthorizationForm.valid || isSaveDisabled(updateAuthorizationForm.value)">
          <mat-icon>save</mat-icon>
          Update Authorization
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelUpdate()"
                matTooltip="Click here to Cancel" [disabled]="isSaveDisabled(undefined)">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
  
  
      </mat-card-actions>
  
      <mat-card-actions align="center">
        <button class="button" mat-raised-button mat-elevation-z8 color="accent"
                matTooltip="Click here to go back to Authorizations page"
                type="button" (click)="backToAuthorizations()">
          <mat-icon>arrow_back</mat-icon>
          Back to Authorizations
        </button>
      </mat-card-actions>
  
    </form>
  </mat-card>
  
  
  
 

import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { AuthorizationModel } from "../models/authorization";

@Component({
  selector: "authorizationedit",
  templateUrl: "authorizationedit.component.html",
  styleUrls: ["authorizationedit.component.css"]
})
export class AuthorizationEdit implements OnInit {

    updateAuthorizationForm: FormGroup;
    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;

    isSaveButtonDisabled: boolean;

    errorMessageActive: boolean = Constant.FALSE;
    successMessageActive: boolean = Constant.FALSE;

    public _username: string = Constant.String_Undefined;
    private updatedAuthorization: AuthorizationModel = new AuthorizationModel();


    constructor(private _dataService: DataService, private _router: Router, private _loader: LoaderService, 
        fb: FormBuilder, private _changeDetector: ChangeDetectorRef) {
        if (this._dataService.currentAuthorizationToEdit !== Constant.NULL && this._dataService.currentAuthorizationToEdit !== Constant.Undefined) {
    
          this.updateAuthorizationForm = fb.group({
            hideRequired: Constant.FALSE,
            floatLabel: Constant.FloatLabel_AUTO
          });
    
          this.updateAuthorizationForm = new FormGroup(
            {
                id: new FormControl({ value: this._dataService.currentAuthorizationToEdit.id, disabled: Constant.TRUE }),
                applicationid: new FormControl({ value: this._dataService.currentAuthorizationToEdit.applicationId, disabled: Constant.TRUE }),
                email: new FormControl({ value: this._dataService.currentAuthorizationToEdit.email, disabled: Constant.TRUE },
                    [Validators.required, Validators.maxLength(Constant.AuthorizationEmailMaxLength),
                    Validators.minLength(Constant.AuthorizationEmailMinLength)])
            });

            this.errorMessageActive = Constant.TRUE;
            this.errorMessage = Constant.Error_EmailCannotBeUpdated;
        }
        else {
          _router.navigate([Constant.ApplicationUrl]);
        }    
    }


    async ngOnInit() {
        this._loader.show();
        await this._dataService.FetchAccessToken();   
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.isSaveButtonDisabled = Constant.TRUE;
          this.mapAuthorizationModels(this._dataService.currentAuthorizationToEdit);
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]);
        }
    }

    ngAfterContentChecked(): void {
        this._changeDetector.detectChanges();
    }
    
    cancelUpdate() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToAuthorizations() {
        this._router.navigate([Constant.AuthorizationUrl]);
    }


    isSaveDisabled(_passedFormAuthorization: AuthorizationModel) {
        if (_passedFormAuthorization !== Constant.Undefined) {
          if (this.updatedAuthorization.email !== _passedFormAuthorization.email) {
            this.isSaveButtonDisabled = Constant.FALSE;
            this.errorMessageActive = Constant.FALSE;
            this.successMessageActive = Constant.FALSE;
          }
          else {
            this.isSaveButtonDisabled = Constant.TRUE;
          }
        }
        return this.isSaveButtonDisabled;
    }

    saveEditOfAuthorization(_passedFormAuthorization: AuthorizationModel) {
    
        // #region Set the Disabled Column Name before we Fire Update request    
        _passedFormAuthorization.id = this._dataService.currentAuthorizationToEdit.id;
        _passedFormAuthorization.applicationId = this._dataService.currentAuthorizationToEdit.applicationId;
        // #endregion
    
        this._loader.show();
    
        this._dataService.updateAuthorization(_passedFormAuthorization)
          .subscribe(
            {
              next: responseText => {
                this.mapAuthorizationModels(_passedFormAuthorization);
                this.isSaveButtonDisabled = Constant.TRUE;
    
                this.successMessage = responseText;
                this.successMessageActive = Constant.TRUE;
                this.errorMessageActive = Constant.FALSE;
    
                this._loader.hide();
              },
              error: err => {
                this.errorMessage = Constant.Error_FailedToUpdateAuthorization;
                this.errorMessageActive = Constant.TRUE;
    
                this._loader.hide();
              }
            });
    }

    mapAuthorizationModels(_passedFormAuthorization: AuthorizationModel) {
        this.updatedAuthorization.email = _passedFormAuthorization.email;
    }
    
    public hasError = (controlName: string, errorName: string) => {
        return this.updateAuthorizationForm.controls[controlName].hasError(errorName);
    }
} 
  

---------------- Authorization -----------------------------






---------------- Current Authorization -----------------------------


<mat-list>
    <h3 matSubheader class="parent">
      <button mat-raised-button mat-elevation-z8 color="warn"
              matTooltip="Click here to confirm deletion of {{data.role}} for Application Id {{ data.applicationId }} and Authorization Id {{ data.authorizationId }} from system"
              (click)="deleteCurrentAuthorization($event)">
        <mat-icon>delete</mat-icon>
        Confirm Deletion of {{ data.role }} for Application Id {{ data.applicationId }} and Authorization Id {{ data.authorizationId }}
      </button>
    </h3>
</mat-list>



table {
    width: inherit;
  }
  
  th.mat-sort-header-sorted {
    color: black;
  }
  
  .mat-row:hover {
    background-color: lightyellow;
  }
  
  .mat-table {
    color: black;
    width: inherit;
  }
  
  .mat-list-item:hover {
    background-color: lightyellow;
  }
  
  
  .parent {
    background-color: #D9EDF7;
  }
  
  .center {
    background-color: yellow;
    display: table; /*shrink to fit width*/
    margin: auto; /*center it*/
  }
  
  .buttoncolor {
    background-color: yellow;
  }
  
  
  <mat-card>

    <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>
  
    <div class="m-2">
  
      <div class="row">
  
        <div class="col-8 alert alert-info mat-elevation-z8" role="alert">
          <h4 class="alert-heading">
            <mat-icon matListIcon>build</mat-icon>
            Current Authorization(s)
          </h4>
          <hr>
          <p class="top">
            Below is the list of all Current Authorization(s) for selected Authorization.
          </p>
        </div>
  
        <div class="col-4">
          <button class="buttoncolor" mat-icon-button mat-elevation-z8 color="warn"
                  matTooltip="Click here to Add New Current Authorization"
                  (click)="addCurrentAuthorization()">
            <mat-icon>apps plus_one</mat-icon>
          </button>
        </div>      
      </div>
  
      <div >
  
        <div style="text-align:center">      
          <mat-table [dataSource]="currentAuthorizations" matSort class="mat-table mat-elevation-z8">
  
            <!--- Note that these columns can be defined in any order.
            The actual rendered columns are set as a property on the row definition" -->
            <!-- Position Column -->

            <ng-container matColumnDef="applicationId">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Application Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.applicationId}} </mat-cell>
            </ng-container>

            <ng-container matColumnDef="authorizationId">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Authorization Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.authorizationId}} </mat-cell>
            </ng-container>

            <ng-container matColumnDef="id">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Current Authorization Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.id}} </mat-cell>
            </ng-container>            
  
            <!-- Name Column -->
            <ng-container matColumnDef="role">
              <mat-header-cell *matHeaderCellDef mat-sort-header> Role </mat-header-cell>
              <mat-cell *matCellDef="let element"> {{element.role}} </mat-cell>
            </ng-container>

            <ng-container matColumnDef="showstatus">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Status </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.showStatus}} </mat-cell>
              </ng-container>
            
  
            <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
            <mat-row style="cursor: pointer" *matRowDef="let row; columns: displayedColumns;" 
                (click)="getCurrentAuthorizationRecord(row.id, row.applicationId, row.authorizationId)">
            </mat-row>
          </mat-table>      
          <mat-paginator [pageSizeOptions]="[5, 10, 20]" showFirstLastButtons></mat-paginator>      
        </div>     
      </div>      
  
      <div class="row">      
        <div *ngIf="rowClicked" style="text-align:center">
          <!-- Div 1-->
          <div class="card text-info rowbackground p-2 mat-elevation-z8">
            <!--Div 2-->
  
            <mat-list>
              <h3 matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to Edit details for {{currentSelectedCurrentAuthorization.role}}"
                        (click)="editCurrentAuthorization(currentSelectedCurrentAuthorization)">
                  <mat-icon>edit</mat-icon>
                  Edit - {{currentSelectedCurrentAuthorization.role}}
                </button>
              </h3>
  
              <h3 matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to Delete {{currentSelectedCurrentAuthorization.role}} from system"
                        (click)="deleteCurrentAuthorization(currentSelectedCurrentAuthorization)">
                  <mat-icon>delete</mat-icon>
                  Delete - {{currentSelectedCurrentAuthorization.role}}
                </button>
              </h3>
  
              <br />
  
              <div matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to Add New CurrentAuthorization for Application Id of: {{currentSelectedCurrentAuthorization.applicationId}} 
                                        and Authorization Id of: {{currentSelectedCurrentAuthorization.authorizationId}}"
                        (click)="addCurrentAuthorization(currentSelectedCurrentAuthorization.applicationId)">
                  <mat-icon>note_add</mat-icon>
                  Add New Current Authorization
                  <mat-icon>plus_one</mat-icon>
                </button>
              </div>
  
              <br />

              <div matSubheader class="parent">
                <button class="center" mat-raised-button mat-elevation-z8 color="accent"
                        matTooltip="Click here to View History Authorization for Application Id of: {{currentSelectedCurrentAuthorization.applicationId}}
                                    and Authorization Id of: and {{currentSelectedCurrentAuthorization.id}} and role of: {{currentSelectedCurrentAuthorization.role}}"
                        (click)="viewHistoryAuthorization(currentSelectedCurrentAuthorization.id, currentSelectedCurrentAuthorization.applicationId, currentSelectedCurrentAuthorization.authorizationId)">
                  <mat-icon>pageview</mat-icon>
                  View - History Authorizations for {{currentSelectedCurrentAuthorization.role}}
                </button>
              </div>
  
              <mat-divider></mat-divider>  

            </mat-list>
  
          </div> <!--Div 2 Ended-->
        </div> <!--Div 1 Ended-->   
      </div>      
    </div>

    <mat-card-actions align="center">
        <button class="button" mat-raised-button mat-elevation-z8 color="accent"
                matTooltip="Click here to go back to Authorization page"
                type="button" (click)="backToAuthorizations()">
          <mat-icon>arrow_back</mat-icon>
          Back to Authorizations
        </button>
    </mat-card-actions>
  </mat-card>
  
  
  
  import { Component, OnInit, ViewChild, OnDestroy, COMPILER_OPTIONS } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";

import { MatPaginator } from "@angular/material/paginator";
import { MatSort } from "@angular/material/sort";
import { MatTableDataSource } from "@angular/material/table";
import { LoaderService } from "../loader/loader.service";
import { CurrentAuthorizationModel } from "../models/currentauthorization";

@Component({
  selector: "currentauthorization",
  templateUrl: "currentauthorization.component.html",
  styleUrls: ["currentauthorization.component.css"]
})
export class CurrentAuthorization implements OnInit { 
    constructor(private _dataService: DataService, private _loader: LoaderService, private _router: Router) { }    

    public displayedColumns: string[] =
    [
      Constant.CurrentAuthorizationColumn_applicationId, 
      Constant.CurrentAuthorizationColumn_authorizationId,
      Constant.CurrentAuthorizationColumn_Id,
      Constant.CurrentAuthorizationColumn_Role,
      Constant.CurrentAuthorizationColumn_ShowStatus
    ];
    public currentAuthorizations: MatTableDataSource<CurrentAuthorizationModel>;

    public currentSelectedCurrentAuthorization: CurrentAuthorizationModel;

    public rowClicked: boolean = Constant.FALSE;
    errorMessage: string = Constant.String_Undefined;
    private _username: string = Constant.String_Undefined;

    @ViewChild(MatSort, { static: Constant.TRUE }) sort: MatSort;
    @ViewChild(MatPaginator, { static: Constant.TRUE }) paginator: MatPaginator;


    async ngOnInit() {

        this._loader.show();   
        await this._dataService.FetchAccessToken();      
  
        this._username = this._dataService.FetchUserName();
  
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) 
        {
            if (this._dataService.viewCurrentAuthorizationForApplicationId !== Constant.NULL && 
                this._dataService.viewCurrentAuthorizationForApplicationId !== Constant.Undefined &&
                this._dataService.viewCurrentAuthorizationForAuthorizationId !== Constant.NULL && 
                this._dataService.viewCurrentAuthorizationForAuthorizationId !== Constant.Undefined)
            {
                this._dataService.loadCurrentAuthorizations()
                .subscribe(
                {
                    next: responseData => {
                    this.currentAuthorizations = new MatTableDataSource<CurrentAuthorizationModel>(responseData);
  
                    this.currentAuthorizations.sort = this.sort;
                    this.currentAuthorizations.paginator = this.paginator;
                    this._loader.hide();
                },
                error: err => 
                {
                    this._loader.hide();
                    this.errorMessage = Constant.FetchCurrentAuthorizationsFailed;
                    this._router.navigate([Constant.ErrorPageUrl,
                    {
                        message: Constant.FetchCurrentAuthorizationsFailed,
                        type: Constant.Error_Type_InternalServiceError
                    }]); 
                }});
            }
            else
            {
                this._router.navigate([Constant.AuthorizationUrl]);
            }
        } 
        else
        {
          // No user Found - Present Error Page.      
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]); 
        }
    }

    public getCurrentAuthorizationRecord(_currentAuthorizationId: number, _applicationId: number, _authorizationId: number) {
        this._loader.show(); 
        this._dataService.loadCurrentAuthorization(_currentAuthorizationId, _applicationId, _authorizationId)
          .subscribe(
            {
              next: responseData => {          
                this._loader.hide();
                this.currentSelectedCurrentAuthorization = responseData;               
                this.rowClicked = Constant.TRUE;                
              },
              error: err => {
                this._loader.hide();
                this.errorMessage = Constant.FetchCurrentAuthorizationFailed;              
              }
            });   
    }


    backToAuthorizations() {
        this._router.navigate([Constant.AuthorizationUrl]);
    }

    public editCurrentAuthorization(_currentAuthorizationToEdit: CurrentAuthorizationModel) {
        this._dataService.editCurrentAuthorization(_currentAuthorizationToEdit);
        this._router.navigate([Constant.CurrentAuthorizationEditUrl]);
    }
    
      public deleteCurrentAuthorization(_currentAuthorizationToDelete: CurrentAuthorizationModel) {
        this._dataService.deleteCurrentAuthorization(_currentAuthorizationToDelete);
        this._router.navigate([Constant.CurrentAuthorizationDeleteUrl]); 
    }
    
      public addCurrentAuthorization() {
        this._router.navigate([Constant.CurrentAuthorizationAddUrl]);
    }
    
      public viewHistoryAuthorization(_currentAuthorizationId: number, _applicationId: number, _authorizationId: number) {
        this._dataService.viewHistoryAuthorizationForApplicationId = _applicationId;
        this._dataService.viewHistoryAuthorizationForAuthorizationId = _authorizationId;
        this._dataService.viewHistoryAuthorizationForCurrentAuthorizationId = _currentAuthorizationId;
        this._router.navigate([Constant.HistoryAuthorizationUrl]);
    }
}





mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
 

<mat-card>
    <div *ngIf="errorMessageActive" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessageActive" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="addCurrentAuthorizationForm"
          autocomplete="off" (ngSubmit)="saveNewCurrentAuthorization(addCurrentAuthorizationForm.value)" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Add a new Current Authorization</mat-card-title>

      <mat-form-field>
        <input matInput #inputapplicationid placeholder="Application Id"
               id="applicationId" formControlName="applicationId" />
      </mat-form-field>

      <mat-form-field>
        <input matInput #inputauthorizationid placeholder="Authorization Id"
               id="authorizationId" formControlName="authorizationId" />
      </mat-form-field>

      <mat-form-field>
        <input matInput #inputrole placeholder="Role"
               maxlength="100" id="role" formControlName="role" />
  
        <mat-hint align="center">{{inputrole.value?.length || 0}}/100</mat-hint>
  
        <mat-error *ngIf="hasError('role', 'required')">Role name is required</mat-error>
        <mat-error *ngIf="hasError('role', 'maxlength')">Only 100 characters are allowed</mat-error>
        <mat-error *ngIf="hasError('role', 'minlength')">At least 2 characters are required</mat-error>
    </mat-form-field>

    <mat-form-field>
        <mat-label>Status</mat-label>
        <mat-select formControlName="status" required>
          <mat-option *ngFor="let selectedstatus of statuses" [value]="selectedstatus.id">
            {{selectedstatus.name}}
          </mat-option>
        </mat-select>
        <mat-error *ngIf="hasError('status')">Please choose a status</mat-error>
    </mat-form-field>
  
      <mat-card-actions align="center">
        <button mat-raised-button color="primary"
                matTooltip="Click here to Save details for {{inputrole.value}}"
                type="submit" [disabled]="!addCurrentAuthorizationForm.valid || isSaveDisabled()">
          <mat-icon>save</mat-icon>
          Save Details
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelSave()"
                matTooltip="Click here to Cancel" [disabled]="isSaveDisabled()">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
      </mat-card-actions>
  
      <mat-card-actions align="center">
        <button type="button" mat-raised-button color="accent" (click)="backToCurrentAuthorizations()"
                matTooltip="Click here to go back to Current Authorizations page">
          <mat-icon>arrow_back</mat-icon>
          Back to Current Authorization(s)
        </button>
      </mat-card-actions>
    </form>
</mat-card>
  


import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { CurrentAuthorizationModel } from "../models/currentauthorization";

@Component({
  selector: "currentauthorizationadd",
  templateUrl: "currentauthorizationadd.component.html",
  styleUrls: ["currentauthorizationadd.component.css"]
})
export class CurrentAuthorizationAdd implements OnInit { 

    addCurrentAuthorizationForm: FormGroup;
    errorMessageActive: boolean = Constant.FALSE;
    successMessageActive: boolean = Constant.FALSE;

    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;
    isSaveButtonDisabled: boolean;

    private _username: string = Constant.String_Undefined;

    public statuses = [
        {"id": Constant.One, "name": Constant.AwaitingApproval},
        {"id": Constant.Two, "name": Constant.Approved},
        {"id": Constant.Three, "name": Constant.Rejected},
        {"id": Constant.Four, "name": Constant.Revoked}
    ];

    constructor(private _dataService: DataService, private _router: Router, 
        private _loader: LoaderService, fb: FormBuilder,
        private _changeDetector: ChangeDetectorRef) {
    
        this.addCurrentAuthorizationForm = fb.group({
          hideRequired: Constant.FALSE,
          floatLabel: Constant.FloatLabel_AUTO
        });
    
        if (this._dataService.viewCurrentAuthorizationForApplicationId !== Constant.NULL && 
            this._dataService.viewCurrentAuthorizationForApplicationId !== Constant.Undefined &&
            this._dataService.viewCurrentAuthorizationForAuthorizationId !== Constant.NULL && 
            this._dataService.viewCurrentAuthorizationForAuthorizationId !== Constant.Undefined){
            this.addCurrentAuthorizationForm = new FormGroup(
            {
                applicationId: new FormControl({ value: this._dataService.viewCurrentAuthorizationForApplicationId, disabled: Constant.TRUE }),
                authorizationId: new FormControl({ value: this._dataService.viewCurrentAuthorizationForAuthorizationId, disabled: Constant.TRUE }),
                role: new FormControl({ value: Constant.String_Undefined, disabled: Constant.FALSE },
                    [Validators.required, Validators.maxLength(Constant.CurrentAuthorizationRoleMaxLength), 
                        Validators.minLength(Constant.CurrentAuthorizationRoleMinLength)]),
                status: new FormControl({ value: Constant.Undefined, disabled: Constant.FALSE }, [Validators.required])
          });
        } else{
            this._router.navigate([Constant.AuthorizationUrl]);
        }
    }

    async ngOnInit() {
        this._loader.show();   
        await this._dataService.FetchAccessToken();   
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.isSaveButtonDisabled = Constant.FALSE;
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]); 
        }
    }

    ngAfterContentChecked(): void {
        this._changeDetector.detectChanges();
    }
    
    cancelSave() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToCurrentAuthorizations() {
        this._router.navigate([Constant.CurrentAuthorizationUrl]);
    }
    
    isSaveDisabled() {
        return this.isSaveButtonDisabled;
    }

    public saveNewCurrentAuthorization = (_passedCurrentAuthorization) => {
        if (this.addCurrentAuthorizationForm.valid) {
          this.saveNewCurrentAuthorizationViaApi(_passedCurrentAuthorization);
        }
    }

    private saveNewCurrentAuthorizationViaApi(_currentAuthorization: CurrentAuthorizationModel) {
        this._loader.show(); 

        _currentAuthorization.applicationId = this._dataService.viewCurrentAuthorizationForApplicationId;
        _currentAuthorization.authorizationId = this._dataService.viewCurrentAuthorizationForAuthorizationId;
        
        this._dataService.addCurrentAuthorization(_currentAuthorization)
          .subscribe(
            {
              next: response => {
                this.isSaveButtonDisabled = Constant.TRUE;
                if (response !== Constant.Undefined) {
                  this.successMessage = Constant.Save_SuccessfulForCurrentAuthorization;
                  this.successMessageActive = Constant.TRUE;
                  this.errorMessageActive = Constant.FALSE;
    
                  this._loader.hide(); 
                }
                else {
                  this.errorMessage = Constant.Error_FailedToSaveCurrentAuthorization;
                  this.errorMessageActive = Constant.TRUE;
                  this.successMessageActive = Constant.FALSE;
    
                  this._loader.hide(); 
                }    
              },
              error: err => {
                this.errorMessage = Constant.Error_FailedToSaveCurrentAuthorization;
                this.errorMessageActive = Constant.TRUE;
                this.successMessageActive = Constant.FALSE;
    
                this._loader.hide();
            }
        });
      }
    
    public hasError = (controlName: string, errorName: string) => {
        return this.addCurrentAuthorizationForm.controls[controlName].hasError(errorName);
    }


}




mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
 <mat-card>
    <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessage" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="deleteCurrentAuthorizationForm"
          autocomplete="off" (ngSubmit)="deleteCurrentAuthorization()" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Delete Role of {{inputrole.value}}</mat-card-title>
  
      <mat-card-content>
        <mat-form-field>
          <input matInput #inputid placeholder="Current Authorization Id"
                 id="id" formControlName="id" />
        </mat-form-field>
  
        <mat-form-field>
          <input matInput #inputapplicationid placeholder="Application Id"
                 id="applicationId" formControlName="applicationId" />
        </mat-form-field>

        <mat-form-field>
            <input matInput #inputauthorizationid placeholder="Authorization Id"
                   id="authorizationId" formControlName="authorizationId" />
        </mat-form-field>

        <mat-form-field>
            <input matInput #inputrole placeholder="Role"
                   id="role" formControlName="role" />
        </mat-form-field>

        <mat-form-field>
            <input matInput #inputshowstatus placeholder="Status"
                   id="showstatus" formControlName="showstatus" />
        </mat-form-field>

      </mat-card-content>
  
      <mat-card-actions align="center">
        <button mat-raised-button color="primary"
                matTooltip="Click here to delete details for {{inputrole.value}} for Application Id of {{inputapplicationid.value}}
                            and Authorization Id of {{inputauthorizationid.value}} "
                type="submit" [disabled]="isDeleteDisabled()">
          <mat-icon>delete</mat-icon>
          Delete {{inputrole.value}} for Application Id of {{inputapplicationid.value}} and Authorization Id of {{inputauthorizationid.value}}
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelDelete()"
                matTooltip="Click here to cancel and return to Applications page" [disabled]="isDeleteDisabled()">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
      </mat-card-actions>
  
  
      <mat-card-actions align="center">
        <button type="button" mat-raised-button color="accent" (click)="backToCurrentAuthorizations()"
                matTooltip="Click here to go back to Current Authorizations page">
          <mat-icon>arrow_back</mat-icon>
          Back to CurrentAuthorizations
        </button>
      </mat-card-actions>
    </form>
</mat-card>
  
  
  
  import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef, Inject } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { MatBottomSheet, MatBottomSheetRef, MAT_BOTTOM_SHEET_DATA } from "@angular/material/bottom-sheet";
import { CurrentAuthorizationModel } from "../models/currentauthorization";

@Component({
  selector: "currentauthorizationdelete",
  templateUrl: "currentauthorizationdelete.component.html",
  styleUrls: ["currentauthorizationdelete.component.css"]
})
export class CurrentAuthorizationDelete implements OnInit { 

    deleteCurrentAuthorizationForm: FormGroup;
    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;
    private currentAuthorization: CurrentAuthorizationModel;
    isDeleteButtonDisabled: boolean;
    private _username: string = Constant.String_Undefined;

    constructor(private _dataService: DataService, private _router: Router, 
        private _loader: LoaderService, fb: FormBuilder, private _bottomSheet: MatBottomSheet) {

        if (this._dataService.current_currentAuthorizationToDelete !== Constant.NULL && 
            this._dataService.current_currentAuthorizationToDelete !== Constant.Undefined) {

                this.deleteCurrentAuthorizationForm = fb.group({
                    hideRequired: Constant.FALSE,
                    floatLabel: Constant.FloatLabel_AUTO
                });
    
                this.deleteCurrentAuthorizationForm = new FormGroup(
                {
                    id: new FormControl({ value: this._dataService.current_currentAuthorizationToDelete.id, disabled: Constant.TRUE }),
                    applicationId: new FormControl({ value: this._dataService.current_currentAuthorizationToDelete.applicationId, disabled: Constant.TRUE }),
                    authorizationId: new FormControl({ value: this._dataService.current_currentAuthorizationToDelete.authorizationId, disabled: Constant.TRUE }),
                    role: new FormControl({ value: this._dataService.current_currentAuthorizationToDelete.role, disabled: Constant.TRUE }),
                    showstatus: new FormControl({ value: this.showStatusIs(), disabled: Constant.TRUE })
                });
            }
        else {
            _router.navigate([Constant.AuthorizationUrl]);
        }  
    }

    async ngOnInit() {
        this._loader.show();  
        await this._dataService.FetchAccessToken();    
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.currentAuthorization = this._dataService.current_currentAuthorizationToDelete;
          this._dataService.deleteCurrentAuthorizationBottomSheetConfirmed(Constant.FALSE);
          this.isDeleteButtonDisabled = Constant.FALSE;
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]);
        }
    }

    cancelDelete() {
        this._router.navigate([Constant.ApplicationUrl]);
    }
    
    backToCurrentAuthorizations() {
        this._router.navigate([Constant.CurrentAuthorizationUrl]);
    }
    
    isDeleteDisabled() {
        return this.isDeleteButtonDisabled;
    }

    deleteCurrentAuthorization() {
        const _bottomSheetRef = this._bottomSheet.open(CurrentAuthorizationDeleteBottomSheet, {
          data: 
          { 
              role: [this.currentAuthorization.role], 
              applicationid: [this.currentAuthorization.applicationId],
              authorizationId: [this.currentAuthorization.authorizationId]  
            }
        });
    
        _bottomSheetRef
          .afterDismissed()
          .subscribe(
            {
              next: (responseData) => {
                if (this._dataService.deleteCurrentAuthorizationBottomSheetClicked) {
    
                  this._loader.show();
    
                  this._dataService.deleteChoosenCurrentAuthorization(this.currentAuthorization )
                    .subscribe(
                      {
                        next: responseData => {
                          this.isDeleteButtonDisabled = Constant.TRUE;
                          this.successMessage = responseData;
    
                          this._loader.hide();
                        },
                        error: err => {
                          this.isDeleteButtonDisabled = Constant.FALSE;
                          this.errorMessage = Constant.DeleteCurrentAuthorizationFailed;
    
                          this._loader.hide();
                        }
                      });
                }
              },
              error: (err) => {
                // Nothing here.
              }
            }); 
    }

    public hasError = (controlName: string, errorName: string) => {
        return this.deleteCurrentAuthorizationForm.controls[controlName].hasError(errorName);
    }

    private showStatusIs() : string {
        if(this._dataService.current_currentAuthorizationToDelete.status === Constant.One)
        {
            return Constant.AwaitingApproval;
        }
        else if(this._dataService.current_currentAuthorizationToDelete.status == Constant.Two)
        {
            return Constant.Approved;
        }
        else if(this._dataService.current_currentAuthorizationToDelete.status == Constant.Three)
        {
            return Constant.Rejected;
        }
        else{
            return Constant.Revoked;
        }
    }
}


@Component({
    selector: 'currentauthorization-delete-bottom-sheet-dialog',
    templateUrl: 'currentauthorization-delete-bottom-sheet.html',
  })
  export class CurrentAuthorizationDeleteBottomSheet {
    constructor(private _bottomSheetRef: MatBottomSheetRef<CurrentAuthorizationDeleteBottomSheet>,
      private _dataServiceCurrentAuthorizationBottomSheet: DataService,
      @Inject(MAT_BOTTOM_SHEET_DATA) public data: any) { }
  
    openLink(event: MouseEvent): void {
      this._bottomSheetRef.dismiss();
      event.preventDefault();
    }
  
    deleteCurrentAuthorization(event: MouseEvent) {
      this._dataServiceCurrentAuthorizationBottomSheet
        .deleteCurrentAuthorizationBottomSheetConfirmed(Constant.TRUE);
  
      this._bottomSheetRef.dismiss();
      event.preventDefault();
    }
}




mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
  

<mat-card>
    <div *ngIf="errorMessageActive" class="alert alert-danger">{{ errorMessage }}</div>
    <div *ngIf="successMessageActive" class="alert alert-success">{{ successMessage }}</div>
  
    <form novalidate [formGroup]="updateCurrentAuthorizationForm"
          autocomplete="off" (ngSubmit)="saveEditOfCurrentAuthorization(updateCurrentAuthorizationForm.value)" fxLayout="column wrap"
          fxLayoutAlign="center center" fxLayoutGap="10px">
  
      <mat-card-title>Update Current Authorization</mat-card-title>
  
      <mat-card-content>
  
        <mat-form-field>
          <input matInput #inputid placeholder="Id" 
            id="id" formControlName="id" />
        </mat-form-field>

        <mat-form-field>
            <input matInput #inputapplicationid placeholder="Application Id" 
                id="applicationId" formControlName="applicationId" />
        </mat-form-field>

        <mat-form-field>
            <input matInput #inputauthorizationid placeholder="Authorization Id" 
                id="authorizationId" formControlName="authorizationId" />
        </mat-form-field>
  
        <mat-form-field>
            <input matInput #inputrole placeholder="Role"
                   maxlength="100" id="role" formControlName="role" />
      
            <mat-hint align="center">{{inputrole.value?.length || 0}}/100</mat-hint>
      
            <mat-error *ngIf="hasError('role', 'required')">Role name is required</mat-error>
            <mat-error *ngIf="hasError('role', 'maxlength')">Only 100 characters are allowed</mat-error>
            <mat-error *ngIf="hasError('role', 'minlength')">At least 2 characters are required</mat-error>
        </mat-form-field>
    
        <mat-form-field>
            <mat-label>Status</mat-label>
            <mat-select formControlName="status" required>
              <mat-option *ngFor="let selectedstatus of statuses" [value]="selectedstatus.id">
                {{selectedstatus.name}}
              </mat-option>
            </mat-select>
            <mat-error *ngIf="hasError('status')">Please choose a status</mat-error>
        </mat-form-field>         
  
      </mat-card-content>
  
  
      <mat-card-actions align="center">
  
        <button mat-raised-button color="primary"
                matTooltip="Click here to Save details for {{inputrole.value}}"
                type="submit" [disabled]="!updateCurrentAuthorizationForm.valid || isSaveDisabled(updateCurrentAuthorizationForm.value)">
          <mat-icon>save</mat-icon>
          Update CurrentAuthorization
        </button>
  
        <button type="button" mat-raised-button color="warn" (click)="cancelUpdate()"
                matTooltip="Click here to Cancel" [disabled]="isSaveDisabled(undefined)">
          <mat-icon>cancel_presentation</mat-icon>
          Cancel
        </button>
  
  
      </mat-card-actions>
  
      <mat-card-actions align="center">
        <button class="button" mat-raised-button mat-elevation-z8 color="accent"
                matTooltip="Click here to go back to CurrentAuthorizations page"
                type="button" (click)="backToCurrentAuthorizations()">
          <mat-icon>arrow_back</mat-icon>
          Back to CurrentAuthorizations
        </button>
      </mat-card-actions>
  
    </form>
  </mat-card>
  
  
  
  import { Component, OnInit, ViewChild, OnDestroy, ChangeDetectorRef } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule } from "@angular/forms";
import { LoaderService } from "../loader/loader.service";
import { CurrentAuthorizationModel } from "../models/currentauthorization";

@Component({
  selector: "currentauthorizationedit",
  templateUrl: "currentauthorizationedit.component.html",
  styleUrls: ["currentauthorizationedit.component.css"]
})
export class CurrentAuthorizationEdit implements OnInit {


    updateCurrentAuthorizationForm: FormGroup;
    errorMessage: string = Constant.String_Undefined;
    successMessage: string = Constant.String_Undefined;

    isSaveButtonDisabled: boolean;

    errorMessageActive: boolean = Constant.FALSE;
    successMessageActive: boolean = Constant.FALSE;

    public _username: string = Constant.String_Undefined;
    private updatedCurrentAuthorization: CurrentAuthorizationModel = new CurrentAuthorizationModel();

    private _statusDisabled : boolean = Constant.FALSE;

    public statuses = [
      {"id": Constant.One, "name": Constant.AwaitingApproval},
      {"id": Constant.Two, "name": Constant.Approved},
      {"id": Constant.Three, "name": Constant.Rejected},
      {"id": Constant.Four, "name": Constant.Revoked}
    ];


    constructor(private _dataService: DataService, private _router: Router, private _loader: LoaderService, 
        fb: FormBuilder, private _changeDetector: ChangeDetectorRef) {
        if (this._dataService.current_currentAuthorizationToEdit !== Constant.NULL && 
            this._dataService.current_currentAuthorizationToEdit !== Constant.Undefined) {
    
          this.updateCurrentAuthorizationForm = fb.group({
            hideRequired: Constant.FALSE,
            floatLabel: Constant.FloatLabel_AUTO
          });
    
          this.updateCurrentAuthorizationForm = new FormGroup(
            {
                id: new FormControl({ value: this._dataService.current_currentAuthorizationToEdit.id, disabled: Constant.TRUE }),
                applicationId: new FormControl({ value: this._dataService.current_currentAuthorizationToEdit.applicationId, disabled: Constant.TRUE }),
                authorizationId: new FormControl({ value: this._dataService.current_currentAuthorizationToEdit.authorizationId, disabled: Constant.TRUE }),
                role: new FormControl({ value: this._dataService.current_currentAuthorizationToEdit.role, disabled: Constant.TRUE },
                    [Validators.required, Validators.maxLength(Constant.CurrentAuthorizationRoleMaxLength), 
                        Validators.minLength(Constant.CurrentAuthorizationRoleMinLength)]),
                status: new FormControl({ value: this._dataService.current_currentAuthorizationToEdit.status, disabled: this._statusDisabled }, 
                    [Validators.required])
            });

            this.errorMessageActive = Constant.TRUE;
            this.errorMessage = Constant.Error_EmailCannotBeUpdated;
        }
        else {
          _router.navigate([Constant.CurrentAuthorizationUrl]);
        }    
    }

    async ngOnInit() {
        this._loader.show();
        await this._dataService.FetchAccessToken();   
    
        this._username = this._dataService.FetchUserName();
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) {
          this.isSaveButtonDisabled = Constant.TRUE;
          this.mapCurrentAuthorizationModels(this._dataService.current_currentAuthorizationToEdit);
          this._loader.hide();
        } else {
          // No user Found - Present Error Page.
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]);
        }
    }

    ngAfterContentChecked(): void {
        this._changeDetector.detectChanges();
    }
    
    cancelUpdate() {
        this._router.navigate([Constant.DashboardUrl]);
    }
    
    backToCurrentAuthorizations() {
        this._router.navigate([Constant.CurrentAuthorizationUrl]);
    }

    isSaveDisabled(_passedFormCurrentAuthorization: CurrentAuthorizationModel) {
        if (_passedFormCurrentAuthorization !== Constant.Undefined) {
          if (this.updatedCurrentAuthorization.status !== _passedFormCurrentAuthorization.status) {
            this.isSaveButtonDisabled = Constant.FALSE;
            this.errorMessageActive = Constant.FALSE;
            this.successMessageActive = Constant.FALSE;
          }
          else {
            this.isSaveButtonDisabled = Constant.TRUE;
          }
        }
        return this.isSaveButtonDisabled;
    }

    saveEditOfCurrentAuthorization(_passedFormCurrentAuthorization: CurrentAuthorizationModel) {
    
        // #region Set the Disabled Column Name before we Fire Update request    
        _passedFormCurrentAuthorization.id = this._dataService.current_currentAuthorizationToEdit.id;
        _passedFormCurrentAuthorization.applicationId = this._dataService.current_currentAuthorizationToEdit.applicationId;
        _passedFormCurrentAuthorization.authorizationId = this._dataService.current_currentAuthorizationToEdit.authorizationId;
        _passedFormCurrentAuthorization.role = this._dataService.current_currentAuthorizationToEdit.role;
        // #endregion
    
        this._loader.show();
    
        this._dataService.updateCurrentAuthorization(_passedFormCurrentAuthorization)
          .subscribe(
            {
              next: responseText => {
                this.mapCurrentAuthorizationModels(_passedFormCurrentAuthorization);
                this.isSaveButtonDisabled = Constant.TRUE;
    
                this.successMessage = responseText;
                this.successMessageActive = Constant.TRUE;
                this.errorMessageActive = Constant.FALSE;

                this._statusDisabled = Constant.TRUE;
    
                this._loader.hide();
              },
              error: err => {
                this.errorMessage = Constant.Error_FailedToUpdateCurrentAuthorization;
                this.errorMessageActive = Constant.TRUE;
    
                this._loader.hide();
              }
            });
    }

    mapCurrentAuthorizationModels(_passedFormCurrentAuthorization: CurrentAuthorizationModel) {
        this.updatedCurrentAuthorization.status = _passedFormCurrentAuthorization.status;
    }
    
    public hasError = (controlName: string, errorName: string) => {
        return this.updateCurrentAuthorizationForm.controls[controlName].hasError(errorName);
    }


}




---------------- Current Authorization -----------------------------








---------------- History Authorization -----------------------------




mat-card {
    display: flex;
    flex-flow: column wrap;
    align-items: center;
  }
  
  mat-form-field {
    display: flex;
    flex-flow: column wrap;
    text-align: match-parent;
    margin-top: auto;
  }
  
  mat-card-title {
    text-align: center;
  }
  
  .mat-form-field:hover {
    background-color: lightyellow;
  }
  
  
  <mat-card>

    <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>
  
    <div class="m-2">
  
      <div class="row">
  
        <div class="col-8 alert alert-info mat-elevation-z8" role="alert">
          <h4 class="alert-heading">
            <mat-icon matListIcon>build</mat-icon>
            History Authorization(s)
          </h4>
          <hr>
          <p class="top">
            Below is the list of all History Authorization(s) for selected Current Authorization.
          </p>
        </div>    
      </div>
  
      <div >
  
        <div style="text-align:center">      
          <mat-table [dataSource]="historyAuthorizations" matSort class="mat-table mat-elevation-z8">
  
            <!--- Note that these columns can be defined in any order.
            The actual rendered columns are set as a property on the row definition" -->
            <!-- Position Column -->

            <ng-container matColumnDef="applicationId">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Application Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.applicationId}} </mat-cell>
            </ng-container>

            <ng-container matColumnDef="authorizationId">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Authorization Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.authorizationId}} </mat-cell>
            </ng-container>

            <ng-container matColumnDef="currentAuthorizationId">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Current Authorization Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.currentAuthorizationId}} </mat-cell>
            </ng-container>   
            
            <ng-container matColumnDef="id">
                <mat-header-cell *matHeaderCellDef mat-sort-header> History Authorization Id </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.id}} </mat-cell>
            </ng-container> 
  
            <!-- Name Column -->
            <ng-container matColumnDef="role">
              <mat-header-cell *matHeaderCellDef mat-sort-header> Role </mat-header-cell>
              <mat-cell *matCellDef="let element"> {{element.role}} </mat-cell>
            </ng-container>

            <ng-container matColumnDef="showstatus">
                <mat-header-cell *matHeaderCellDef mat-sort-header> Status </mat-header-cell>
                <mat-cell *matCellDef="let element"> {{element.showStatus}} </mat-cell>
              </ng-container>
            
  
            <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
            <mat-row style="cursor: pointer" *matRowDef="let row; columns: displayedColumns;">
            </mat-row>
          </mat-table>      
          <mat-paginator [pageSizeOptions]="[5, 10, 20]" showFirstLastButtons></mat-paginator>      
        </div>     
      </div>         
    </div>

    <mat-card-actions align="center">
        <button class="button" mat-raised-button mat-elevation-z8 color="accent"
                matTooltip="Click here to go back to Current Authorization page"
                type="button" (click)="backToCurrentAuthorizations()">
          <mat-icon>arrow_back</mat-icon>
          Back to Current Authorizations
        </button>
    </mat-card-actions>
  </mat-card>
  
  
  
  import { Component, OnInit, ViewChild, OnDestroy, COMPILER_OPTIONS } from "@angular/core";
import { DataService } from "../shared/dataService";
import { Router } from '@angular/router';
import { Constant } from "../shared/Constant";

import { MatPaginator } from "@angular/material/paginator";
import { MatSort } from "@angular/material/sort";
import { MatTableDataSource } from "@angular/material/table";
import { LoaderService } from "../loader/loader.service";
import { HistoryAuthorizationModel } from "../models/historyauthorization";

@Component({
  selector: "historyauthorization",
  templateUrl: "historyauthorization.component.html",
  styleUrls: ["historyauthorization.component.css"]
})
export class HistoryAuthorization implements OnInit { 
    constructor(private _dataService: DataService, private _loader: LoaderService, private _router: Router) { }  



    public displayedColumns: string[] =
    [
      Constant.HistoryAuthorizationColumn_applicationId, 
      Constant.HistoryAuthorizationColumn_authorizationId,
      Constant.HistoryAuthorizationColumn_currentauthorizationId,
      Constant.HistoryAuthorizationColumn_Role,
      Constant.HistoryAuthorizationColumn_ShowStatus
    ];
    public historyAuthorizations: MatTableDataSource<HistoryAuthorizationModel>;

    errorMessage: string = Constant.String_Undefined;
    private _username: string = Constant.String_Undefined;

    @ViewChild(MatSort, { static: Constant.TRUE }) sort: MatSort;
    @ViewChild(MatPaginator, { static: Constant.TRUE }) paginator: MatPaginator;


    async ngOnInit() {

        this._loader.show();   
        await this._dataService.FetchAccessToken();      
  
        this._username = this._dataService.FetchUserName();
  
        if (this._username !== Constant.NULL && this._username !== Constant.String_Undefined) 
        {
            if (this._dataService.viewHistoryAuthorizationForApplicationId !== Constant.NULL && 
                this._dataService.viewHistoryAuthorizationForApplicationId !== Constant.Undefined &&
                this._dataService.viewHistoryAuthorizationForAuthorizationId !== Constant.NULL && 
                this._dataService.viewHistoryAuthorizationForAuthorizationId !== Constant.Undefined)
            {
                this._dataService.loadHistoryAuthorizations()
                .subscribe(
                {
                    next: responseData => {
                    this.historyAuthorizations = new MatTableDataSource<HistoryAuthorizationModel>(responseData);
  
                    this.historyAuthorizations.sort = this.sort;
                    this.historyAuthorizations.paginator = this.paginator;
                    this._loader.hide();
                },
                error: err => 
                {
                    this._loader.hide();
                    this.errorMessage = Constant.FetchHistoryAuthorizationsFailed;
                    this._router.navigate([Constant.ErrorPageUrl,
                    {
                        message: Constant.FetchHistoryAuthorizationsFailed,
                        type: Constant.Error_Type_InternalServiceError
                    }]); 
                }});
            }
            else
            {
                this._router.navigate([Constant.CurrentAuthorizationUrl]);
            }
        } 
        else
        {
          // No user Found - Present Error Page.      
          this._loader.hide();
          this._router.navigate([Constant.ErrorPageUrl,
          {
            message: Constant.PermissionErrorMessageAccess,
            type: Constant.Error_Type_Permission
          }]); 
        }
    }

    backToCurrentAuthorizations() {
        this._router.navigate([Constant.CurrentAuthorizationUrl]);
    }
}


  
  




---------------- History Authorization -----------------------------


























-------------------Constants -----------------------------------

import { ConfigService } from "./configService";
import appsettings from "../../assets/appsettings.json";


export class Constant
{
    public _config: ConfigService;

    // #region - Pick below values from Config.JSON File
    public static API_URL: string = undefined;
    public static AzureClientId: string = undefined;
    public static AzureAuthority: string = undefined;
    public static RedirectURL: string = undefined;
    public static PostLogoutRedirectURL: string = undefined;
    public static GRAPH_Url: string= undefined; 
    public static CallB2CWebScope: string = undefined; 
    // #endregion

    constructor(private _fetchedConfig: ConfigService)  {
        this._config = _fetchedConfig;
    }

    static initialize() {
        console.log("  ---> **** Constants Initialise Start **** <---");
        console.log(appsettings);
    
        Constant.API_URL = appsettings.ApiUrl;
        Constant.AzureClientId = appsettings.ClientId;
        Constant.AzureAuthority = appsettings.Authority;
        Constant.RedirectURL = appsettings.RedirectUrl;
        Constant.PostLogoutRedirectURL = appsettings.PostLogoutRedirectUrl; 
        Constant.GRAPH_Url = appsettings.GRAPH_Url;
        Constant.CallB2CWebScope = appsettings.CallB2CWebScope;

        console.log("  ---> **** Constants Initialised Complete **** <---");
    }

    // #region - MSAL Settings.

    // CallB2CWebScope should be from config file.
    

    public static GRAPH_UserReadScope = "user.read";
    public static OpenIdScope = "openid";
    public static ProfileScope = "profile";

    public static SessionStorage = "sessionStorage";
    public static CorrelationId = "1234";
    // #endregion


    public static Error_Type_InternalServiceError = "Internal Service Error";
    public static Error_FailedToFetchDetails = "Failed to fetch details, please try again.";



    // #region - Routes.
    public static DefaultRoute = "";

    public static Dashboard = "dashboard";
    public static DashboardUrl = "/dashboard";

    public static ErrorPage = "error";
    public static ErrorPageUrl = "/error";

    public static Application = "application";
    public static ApplicationUrl = "/application";

    public static ApplicationAdd = "application-add";
    public static ApplicationAddUrl = "/application-add";

    public static ApplicationEdit = "application-edit";
    public static ApplicationEditUrl = "/application-edit";

    public static ApplicationDelete = "application-delete";
    public static ApplicationDeleteUrl = "/application-delete";

    public static Authorization = "authorization";
    public static AuthorizationUrl = "/authorization";

    public static AuthorizationAdd = "authorization-add";
    public static AuthorizationAddUrl = "/authorization-add";

    public static AuthorizationEdit = "authorization-edit";
    public static AuthorizationEditUrl = "/authorization-edit";

    public static AuthorizationDelete = "authorization-delete";
    public static AuthorizationDeleteUrl = "/authorization-delete";

    public static CurrentAuthorization = "current-authorization";
    public static CurrentAuthorizationUrl = "/current-authorization";

    public static CurrentAuthorizationAdd = "current-authorization-add";
    public static CurrentAuthorizationAddUrl = "/current-authorization-add";

    public static CurrentAuthorizationEdit = "current-authorization-edit";
    public static CurrentAuthorizationEditUrl = "/current-authorization-edit";

    public static CurrentAuthorizationDelete = "current-authorization-delete";
    public static CurrentAuthorizationDeleteUrl = "/current-authorization-delete";

    public static HistoryAuthorization = "history-authorization";
    public static HistoryAuthorizationUrl = "/history-authorization";

    public static HistoryAuthorizationnAdd = "history-authorization-add";
    public static HistoryAuthorizationAddUrl = "/history-authorization-add";

    public static HistoryAuthorizationEdit = "history-authorization-edit";
    public static HistoryAuthorizationEditUrl = "/history-authorization-edit";

    public static HistoryAuthorizationDelete = "history-authorization-delete";
    public static HistoryAuthorizationDeleteUrl = "/history-authorization-delete";

    // #endregion

    public static ApplicationColumn_AzureApplicationId = "azureApplicationId";
    public static ApplicationColumn_DisplayName = "displayName";
    public static ApplicationColumn_Id = "id";

    public static AuthorizationColumn_applicationId = "applicationId";
    public static AuthorizationColumn_email = "email";
    public static AuthorizationColumn_Id = "id";

    public static CurrentAuthorizationColumn_applicationId = "applicationId";
    public static CurrentAuthorizationColumn_authorizationId = "authorizationId";
    public static CurrentAuthorizationColumn_Id = "id";
    public static CurrentAuthorizationColumn_Role = "role";
    public static CurrentAuthorizationColumn_ShowStatus = "showstatus";

    public static HistoryAuthorizationColumn_applicationId = "applicationId";
    public static HistoryAuthorizationColumn_authorizationId = "authorizationId";
    public static HistoryAuthorizationColumn_currentauthorizationId = "currentAuthorizationId";
    public static HistoryAuthorizationColumn_Role = "role";
    public static HistoryAuthorizationColumn_ShowStatus = "showstatus";

    public static API_Operations_Url = "operations";

    public static API_Application_Url = "application";
    public static API_Authorization_Url = "authorization";
    public static API_CurrentAuthorization_Url = "currentauthorization";
    public static API_HistoryAuthorization_Url = "historyauthorization";

    public static Date_AU_Locale = "en-AU";
    public static Includes_GMT = "GMT";

    public static ServerError = "Server error";
    public static FolderPath_AppSettings = "assets/appsettings.json";
    public static FolderPath_AppSettingsToFoldersUp = "../../assets/appsettings.json";
    public static FolderPath_VersionAzureSettings = "assets/versionazure.json";

    public static MsalAcquireTokenSuccess = "msal:acquireTokenSuccess";
    public static MsalAcquireTokenFailure = "msal:acquireTokenFailure";

    public static MsalLoginSuccess = "msal:loginSuccess";
    public static MsalLoginFailure = "msal:loginFailure";

    public static ConsentRequired = "consent_required";
    public static InteractionRequired = "interaction_required";
    public static NegativeOne: number = -1;
    public static Operation = "operation";

    public static PermissionErrorMessageAccess:string ="You don't have permission to access this feature, please contact the administrator.";
    public static Error_Type_Permission = "Permission"; 


    public static FetchApplicationsFailed: string = "Fetch Applications has Failed.";
    public static FetchAuthorizationsFailed: string = "Fetch Authorizations has Failed.";
    public static FetchCurrentAuthorizationsFailed: string = "Fetch Current Authorizations has Failed.";
    public static FetchHistoryAuthorizationsFailed: string = "Fetch History of Authorizations has Failed.";
    public static FetchApplicationFailed: string = "Fetch Application has Failed.";
    public static FetchAuthorizationFailed: string = "Fetch Authorization has Failed.";
    public static FetchCurrentAuthorizationFailed: string = "Fetch Current Authorization has Failed.";
    public static FetchHistoryAuthorizationFailed: string = "Fetch History of Authorization has Failed.";

    public static AddApplicationFailed: string = "Add Application has Failed.";
    public static AddAuthorizationFailed: string = "Add Authorization has Failed.";
    public static AddCurrentAuthorizationFailed: string = "Add Current Authorization has Failed.";
    public static AddHistoryAuthorizationFailed: string = "Add History of Authorization has Failed.";

    public static UpdateApplicationFailed: string = "Update Application has Failed.";
    public static UpdateAuthorizationFailed: string = "Update Authorization has Failed.";
    public static UpdateCurrentAuthorizationFailed: string = "Update Current Authorization has Failed.";
    public static UpdateHistoryAuthorizationFailed: string = "Update History of Authorization has Failed.";

    public static DeleteApplicationFailed: string = "Delete Application has Failed.";
    public static DeleteAuthorizationFailed: string = "Delete Authorization has Failed.";
    public static DeleteCurrentAuthorizationFailed: string = "Delete Current Authorization has Failed.";
    public static DeleteHistoryAuthorizationFailed: string = "Delete History of Authorization has Failed.";

    public static Error_FailedToUpdateApplication = "Failed to update application, please try again.";
    public static Error_FailedToUpdateAuthorization = "Failed to update authorization, please try again.";
    public static Error_FailedToUpdateCurrentAuthorization = "Failed to update Current Authorization, please try again.";
    public static Error_FailedToUpdateHistoryAuthorization = "Failed to update History Authorization, please try again.";

    public static Error_EmailCannotBeUpdated = "Email address is a key and as such cannot be updated. This functionality is not available as part of this release.";

    public static Forward_Slash = "/";
    public static Question_Mark = "?";
    public static Equals_Sign = "=";
    public static Ampersand_Sign = "&";

    public static Authorization_Id = "authorizationId";
    public static Application_Id = "applicationId";
    public static CurrentAuthorization_Id = "currentauthorizationId";

    public static API_APPLICATIONS_ENDPOINT = "application";
    public static API_AUTHORIZATIONS_ENDPOINT = "authorization";
    public static API_CURRENT_AUTHORIZATIONS_ENDPOINT = "currentauthorization";
    public static API_HISTORY_AUTHORIZATIONS_ENDPOINT = "historyauthorization";

    public static AzureApplicationIdMaxLength: number = 36; 
    public static ApplicationDisplayNameMaxLength: number = 100; 
    public static ApplicationDisplayNameMinLength: number = 5;

    public static AuthorizationEmailMaxLength: number = 500; 
    public static AuthorizationEmailMinLength: number = 5;

    public static CurrentAuthorizationRoleMaxLength: number = 100; 
    public static CurrentAuthorizationRoleMinLength: number = 2;

    public static Id: string = "id";
    public static Name: string = "name";

    public static AwaitingApproval: string = "Awaiting Approval";
    public static Approved: string = "Approved";
    public static Rejected: string = "Rejected";
    public static Revoked: string = "Revoked";

    public static One: number = 1;
    public static Two: number = 2;
    public static Three: number = 3;
    public static Four: number = 4;

    public static Save_SuccessfulForApplication = "Save Successful. New application details have been added.";
    public static Save_SuccessfulForAuthorization = "Save Successful. New authorization details have been added.";
    public static Save_SuccessfulForCurrentAuthorization = "Save Successful. New Current Authorization details have been added.";
    public static Save_SuccessfulForHistoryAuthorization = "Save Successful. New History Authorization details have been added.";

    public static Error_FailedToSaveApplication = "Failed to add new application details, please try again.";
    public static Error_FailedToSaveAuthorization = "Failed to add new authorization details, please try again.";
    public static Error_FailedToSaveCurrentAuthorization = "Failed to add new Current Authorization details, please try again.";
    public static Error_FailedToSaveHistoryAuthorization = "Failed to add new History Authorization details, please try again.";

    public static FloatLabel_AUTO = "auto";

    public static TRUE: boolean  = true;
    public static FALSE: boolean  = false;
    public static NULL  = null;
    public static String_Undefined: string = undefined; 
    public static Undefined = undefined; 
}

-------------------Constants ------------------------------------




------------------- Data Service ------------------------------------

import { Injectable, OnInit, OnDestroy } from "@angular/core";
import { HttpClient, HttpHeaders, HttpResponse } from "@angular/common/http";
import { Router } from "@angular/router";
import { Observable, of } from "rxjs";
import { catchError, map, tap, concat } from "rxjs/operators";
import { Constant } from "./Constant";
import { BroadcastService, MsalService } from "@azure/msal-angular";
import { Subscription } from "rxjs/Subscription";
import { User } from "msal";
import { ApplicationModel } from "../models/application";
import { AuthorizationModel } from "../models/authorization";
import { CurrentAuthorizationModel } from "../models/currentauthorization";
import { HistoryAuthorizationModel } from "../models/historyauthorization";


@Injectable()
export class DataService implements OnInit, OnDestroy {

    private userData: any = Constant.NULL;
    private subscription: Subscription;
    private _user: User = Constant.NULL;

    public subscription_Init : boolean = Constant.FALSE;


    constructor(private http: HttpClient, 
        private router: Router,
        private authService: MsalService,
        private broadcastService: BroadcastService) { }


    private handleError<T>(operation = Constant.Operation, result?: T) {
        return (error: any): Observable<T> => {    
            console.log(`${operation} Please try again!`);

            console.log(error);
            this.router.navigate([Constant.ErrorPageUrl, {message: `${operation} Please try again!`, type: error.name}]);             
            return of(result as T); // Let the app keep running by returning an empty result.
        };
    }

    ngOnInit() {
        this.BroadCastSubscription_Init();
    }

    ngOnDestroy() {
    }

    private BroadCastSubscription_Init(): boolean 
    {
        if (!this.subscription_Init) {
    
          this.subscription = this.broadcastService.subscribe(Constant.MsalAcquireTokenSuccess, (payload) => {
            console.log(" In DataService BroadCastSubscription_Init()----->>> acquire token SUCCESS " + JSON.stringify(payload));
          });
    
          // Will work for acquireTokenSilent and acquireTokenPopup
          this.subscription = this.broadcastService.subscribe(Constant.MsalAcquireTokenFailure, (payload) => {
            console.log("In DataService BroadCastSubscription_Init()----->>> acquire token FALIURE " + JSON.stringify(payload))
    
            if (payload.errorDesc.indexOf(Constant.ConsentRequired) !== Constant.NegativeOne ||
              payload.errorDesc.indexOf(Constant.InteractionRequired) != Constant.NegativeOne) {
    
              this.authService.acquireTokenPopup([Constant.CallB2CWebScope]).then((token) => {
                console.log("In DataService BroadCastSubscription_Init()----->>> acquire token SUCCESS TOKEN IS ->>>> " + JSON.stringify(token))
              }, (error) => {
                console.log("In DataService BroadCastSubscription_Init()----->>> acquire token FAILURE Error IS ->>>> " + JSON.stringify(error))
              });
            }
          });
          this.subscription_Init = Constant.TRUE;
        } else {
          //console.log("*** NOT Data Service NOT ***** :::::: NOT Subcribing To Events NOT :::::::::::::::::::");
        }
        return this.subscription_Init;
      }

    public FetchUserName() : string {
        // here 
        if (this._user === Constant.NULL || this._user === Constant.Undefined) {
            this.FetchUser();
            if (this._user === Constant.NULL || this._user === Constant.Undefined) {
              return Constant.NULL; // User Signed Out.
            }
        }
         return this._user.name;
    }

    private FetchUser(): User {
        this._user = this.authService.getUser();    
        return this._user;
    }

    public async FetchAccessToken(): Promise<boolean> {
        await this.authService.acquireTokenSilent([Constant.CallB2CWebScope]);    
        return Constant.TRUE;
    }

    private getUserProfile() {
        this.http.get<any>(Constant.GRAPH_Url)
          .subscribe(data => {
            this.userData = data;    
          }, error => {
            console.error("DataService getUserProfile()----->>> Http get request to MS Graph failed" + JSON.stringify(error));
          });
    }



    // #region 1 -> Application(s) API related Interaction(s). 

    identityTest(): Observable<string> {
        return this.http.get<string>(Constant.API_URL + "identity")
          .pipe(
            tap(res => {
                console.log("The Returned result is --> " + res);
                return JSON.stringify(res);
            }),
        catchError(this.handleError<any>("Calling IDENTITY Failed!")));
     }

    // #endregion


    // #region 1.1 ->Fetch Application(s).

    public applications: ApplicationModel[] = [];
    public currentApplication: ApplicationModel;

    public currentApplicationToEdit: ApplicationModel;
    public currentApplicationToDelete: ApplicationModel;

    public deleteApplicationBottomSheetClicked: boolean = Constant.FALSE;

    loadApplications(): Observable<ApplicationModel[]> {
      return this.http.get<ApplicationModel[]>(Constant.API_URL + Constant.API_APPLICATIONS_ENDPOINT)
      .pipe(
        tap(res => {
          this.applications = res;
          return JSON.stringify(res);
        }),
        catchError(this.handleError<any>(Constant.FetchApplicationsFailed)));
    }

    loadApplication(_azureAppplicationId: string): Observable<ApplicationModel> {
      return this.http.get<ApplicationModel>(Constant.API_URL + Constant.API_APPLICATIONS_ENDPOINT + Constant.Forward_Slash + _azureAppplicationId)
      .pipe(
        tap(res => {
          this.currentApplication = res;
          return JSON.stringify(res);
        }),
        catchError(this.handleError<any>(Constant.FetchApplicationsFailed)));
    }

  // #endregion

  // #region 1.2 Update Airline(s)

  public editApplication(_applicationToEdit: ApplicationModel) {
    this.currentApplicationToEdit = _applicationToEdit;
  } 

  public updateApplication(_application: ApplicationModel): Observable<string> {
    return this.http.put(Constant.API_URL + Constant.API_APPLICATIONS_ENDPOINT + Constant.Forward_Slash + _application.azureApplicationId,
      _application, { responseType: 'text' })
      .pipe(
        tap(res => { return res; }),
        catchError(this.handleError<any>(Constant.UpdateApplicationFailed)));
  } 

  // #endregion

  // #region 1.3 Insert Airline.

  public addApplication(_application: ApplicationModel): Observable<ApplicationModel> {

    let headers = new HttpHeaders({
      "Content-Type": "application/json; charset=utf-8",
    });
    let options = { headers: headers };

    return this.http.post<ApplicationModel>(Constant.API_URL + Constant.API_APPLICATIONS_ENDPOINT,
      _application, options)
      .pipe(
        tap(res => { return JSON.stringify(res); }), //console.log("Add response"); console.log(res);
        catchError(this.handleError<any>(Constant.AddApplicationFailed)));
  }

  // #endregion


  // #region 1.4 Delete Airline.

  public deleteApplication(_airlineToDelete: ApplicationModel) {
    this.currentApplicationToDelete = _airlineToDelete;
  }

  public deleteApplicationBottomSheetConfirmed(_confirmed: boolean) {
    this.deleteApplicationBottomSheetClicked = _confirmed;
  }

  public deleteChoosenApplication(_application: ApplicationModel): Observable<string> {
    return this.http.delete(Constant.API_URL + Constant.API_APPLICATIONS_ENDPOINT + Constant.Forward_Slash + _application.azureApplicationId,
      { responseType: 'text' })
      .pipe(
        tap(res => { return res; }),
        catchError(this.handleError<any>(Constant.DeleteApplicationFailed, ApplicationModel)));
  } 


  // #endregion


  // #region 2 -> Application(s) API related Interaction(s).

  public authorizations: AuthorizationModel[] = [];
  public currentAuthorization: AuthorizationModel;

  public viewAuthorizationsForApplicationId: number = Constant.Undefined;

  public viewCurrentAuthorizationForApplicationId: number = Constant.Undefined;
  public viewCurrentAuthorizationForAuthorizationId : number = Constant.Undefined;

  public currentAuthorizationToEdit: AuthorizationModel = Constant.Undefined;;
  public currentAuthorizationToDelete: AuthorizationModel = Constant.Undefined;;
  public deleteAuthorizationBottomSheetClicked: boolean = Constant.FALSE;


  loadAuthorizations(): Observable<AuthorizationModel[]> {
    return this.http.get<AuthorizationModel[]>(Constant.API_URL + Constant.API_AUTHORIZATIONS_ENDPOINT +
      Constant.Question_Mark + Constant.Application_Id + Constant.Equals_Sign + this.viewAuthorizationsForApplicationId)
    .pipe(
      tap(res => {
        this.authorizations = res;
        return JSON.stringify(res);
      }),
      catchError(this.handleError<any>(Constant.FetchAuthorizationsFailed)));
  }

  loadAuthorization(_email: string, _applicationId: number): Observable<AuthorizationModel> {
    return this.http.get<AuthorizationModel>(Constant.API_URL + Constant.API_AUTHORIZATIONS_ENDPOINT + 
      Constant.Forward_Slash + _email + Constant.Question_Mark + 
      Constant.Application_Id + Constant.Equals_Sign + _applicationId)
    .pipe(
      tap(res => {
        this.currentAuthorization = res;
        return JSON.stringify(res);
      }),
      catchError(this.handleError<any>(Constant.FetchAuthorizationFailed)));
  }

  public editAuthorization(_authorizationToEdit: AuthorizationModel) {
    this.currentAuthorizationToEdit = _authorizationToEdit;
  } 

  public updateAuthorization(_authorization: AuthorizationModel): Observable<string> {
    return this.http.put(Constant.API_URL + Constant.API_AUTHORIZATIONS_ENDPOINT + Constant.Forward_Slash + _authorization.applicationId,
      _authorization, { responseType: 'text' })
      .pipe(
        tap(res => { return res; }),
        catchError(this.handleError<any>(Constant.UpdateAuthorizationFailed)));
  }

  public addAuthorization(_authorization: AuthorizationModel): Observable<AuthorizationModel> {

    let headers = new HttpHeaders({
      "Content-Type": "application/json; charset=utf-8",
    });
    let options = { headers: headers };

    return this.http.post<AuthorizationModel>(Constant.API_URL + Constant.API_AUTHORIZATIONS_ENDPOINT,
      _authorization, options)
      .pipe(
        tap(res => { return JSON.stringify(res); }), 
        catchError(this.handleError<any>(Constant.AddAuthorizationFailed)));
  }


  public deleteAuthorization(_authorizationToDelete: AuthorizationModel) {
    this.currentAuthorizationToDelete = _authorizationToDelete;
  }

  public deleteAuthorizationBottomSheetConfirmed(_confirmed: boolean) {
    this.deleteAuthorizationBottomSheetClicked = _confirmed;
  }


  public deleteChoosenAuthorization(_authorization: AuthorizationModel): Observable<string> {
    return this.http.delete(Constant.API_URL + Constant.API_AUTHORIZATIONS_ENDPOINT + 
      Constant.Forward_Slash + _authorization.email + Constant.Question_Mark + 
      Constant.Application_Id + Constant.Equals_Sign + _authorization.applicationId,
      { responseType: 'text' })
      .pipe(
        tap(res => { return res; }),
        catchError(this.handleError<any>(Constant.DeleteAuthorizationFailed)));
  }


  // #endregion


  // #region 3 -> Current Application(s) API related Interaction(s).

  public currentAuthorizations: CurrentAuthorizationModel[] = [];
  public current_currentAuthorization: CurrentAuthorizationModel;

  public viewHistoryAuthorizationForApplicationId: number = Constant.Undefined;
  public viewHistoryAuthorizationForAuthorizationId : number = Constant.Undefined;
  public viewHistoryAuthorizationForCurrentAuthorizationId : number = Constant.Undefined;

  public current_currentAuthorizationToEdit: CurrentAuthorizationModel = Constant.Undefined;;
  public current_currentAuthorizationToDelete: CurrentAuthorizationModel = Constant.Undefined;;
  public deleteCurrentAuthorizationBottomSheetClicked: boolean = Constant.FALSE;


  loadCurrentAuthorizations(): Observable<CurrentAuthorizationModel[]> {
    return this.http.get<CurrentAuthorizationModel[]>(Constant.API_URL + Constant.API_CURRENT_AUTHORIZATIONS_ENDPOINT +
      Constant.Question_Mark + Constant.Authorization_Id + Constant.Equals_Sign + this.viewCurrentAuthorizationForAuthorizationId +
      Constant.Ampersand_Sign +
      Constant.Application_Id + Constant.Equals_Sign + this.viewCurrentAuthorizationForApplicationId)
    .pipe(
      tap(res => {

        res.forEach(_element => 
          {
            if(_element.status === Constant.One)
            {
              _element.showStatus = Constant.AwaitingApproval;
            }
            else if(_element.status === Constant.Two)
            {
              _element.showStatus = Constant.Approved;
            }
            else if(_element.status === Constant.Three)
            {
              _element.showStatus = Constant.Rejected;
            }
            else{
              _element.showStatus = Constant.Revoked;
            }
          });

        this.currentAuthorizations = res;
        return JSON.stringify(res);
      }),
      catchError(this.handleError<any>(Constant.FetchCurrentAuthorizationsFailed)));
  }

  loadCurrentAuthorization(_currentAuthorizationId: number,  _applicationId: number, _authorizationId: number)
  : Observable<CurrentAuthorizationModel> {
    return this.http.get<CurrentAuthorizationModel>(Constant.API_URL + Constant.API_CURRENT_AUTHORIZATIONS_ENDPOINT + 
      Constant.Forward_Slash + _currentAuthorizationId + 
      Constant.Question_Mark + 
      Constant.Application_Id + Constant.Equals_Sign + _applicationId +
      Constant.Ampersand_Sign + 
      Constant.Authorization_Id + Constant.Equals_Sign + _authorizationId)
    .pipe(
      tap(res => {
        this.current_currentAuthorization = res;
        return JSON.stringify(res);
      }),
      catchError(this.handleError<any>(Constant.FetchCurrentAuthorizationFailed)));
  }

  public editCurrentAuthorization(_current_currentAuthorizationToEdit: CurrentAuthorizationModel) {
    this.current_currentAuthorizationToEdit = _current_currentAuthorizationToEdit;
  } 

  public updateCurrentAuthorization(_current_currentAuthorization: CurrentAuthorizationModel): Observable<string> {
    return this.http.put(Constant.API_URL + Constant.API_CURRENT_AUTHORIZATIONS_ENDPOINT + Constant.Forward_Slash + _current_currentAuthorization.applicationId,
      _current_currentAuthorization, { responseType: 'text' })
      .pipe(
        tap(res => { return res; }),
        catchError(this.handleError<any>(Constant.UpdateCurrentAuthorizationFailed)));
  }

  public addCurrentAuthorization(_current_currentAuthorization: CurrentAuthorizationModel): Observable<CurrentAuthorizationModel> {

    let headers = new HttpHeaders({
      "Content-Type": "application/json; charset=utf-8",
    });
    let options = { headers: headers };

    return this.http.post<CurrentAuthorizationModel>(Constant.API_URL + Constant.API_CURRENT_AUTHORIZATIONS_ENDPOINT,
      _current_currentAuthorization, options)
      .pipe(
        tap(res => { return JSON.stringify(res); }), 
        catchError(this.handleError<any>(Constant.AddCurrentAuthorizationFailed)));
  }


  public deleteCurrentAuthorization(_current_currentAuthorizationToDelete: CurrentAuthorizationModel) {
    this.current_currentAuthorizationToDelete = _current_currentAuthorizationToDelete;
  }

  public deleteCurrentAuthorizationBottomSheetConfirmed(_confirmed: boolean) {
    this.deleteCurrentAuthorizationBottomSheetClicked = _confirmed;
  }


  public deleteChoosenCurrentAuthorization(_currentAuthorization: CurrentAuthorizationModel): Observable<string> {
    return this.http.delete(Constant.API_URL + Constant.API_CURRENT_AUTHORIZATIONS_ENDPOINT + 
      Constant.Forward_Slash + _currentAuthorization.id + 
      Constant.Question_Mark + 
      Constant.Application_Id + Constant.Equals_Sign + _currentAuthorization.applicationId +
      Constant.Ampersand_Sign + 
      Constant.Authorization_Id + Constant.Equals_Sign + _currentAuthorization.authorizationId,
      { responseType: 'text' })
      .pipe(
        tap(res => { return res; }),
        catchError(this.handleError<any>(Constant.DeleteCurrentAuthorizationFailed)));
  }


  // #endregion


  // #region 4 -> History Auhorization(s) API related Interaction(s).

  public currentHistoryAuthorizations: HistoryAuthorizationModel[] = [];

  loadHistoryAuthorizations(): Observable<HistoryAuthorizationModel[]> {
    return this.http.get<HistoryAuthorizationModel[]>(Constant.API_URL + Constant.API_HISTORY_AUTHORIZATIONS_ENDPOINT +
      Constant.Question_Mark + Constant.Authorization_Id + Constant.Equals_Sign + this.viewHistoryAuthorizationForAuthorizationId +
      Constant.Ampersand_Sign +
      Constant.Application_Id + Constant.Equals_Sign + this.viewHistoryAuthorizationForApplicationId +
      Constant.Ampersand_Sign +
      Constant.CurrentAuthorization_Id + Constant.Equals_Sign + this.viewHistoryAuthorizationForCurrentAuthorizationId)
    .pipe(
      tap(res => { 

        res.forEach(_element => 
          {
            if(_element.previousStatus === Constant.One)
            {
              _element.showStatus = Constant.AwaitingApproval;
            }
            else if(_element.previousStatus === Constant.Two)
            {
              _element.showStatus = Constant.Approved;
            }
            else if(_element.previousStatus === Constant.Three)
            {
              _element.showStatus = Constant.Rejected;
            }
            else{
              _element.showStatus = Constant.Revoked;
            }
          });

        this.currentHistoryAuthorizations = res;
        return JSON.stringify(res);
      }),
      catchError(this.handleError<any>(Constant.FetchHistoryAuthorizationsFailed)));
  }

  // #endregion
}


------------------- Data Service ------------------------------------























import { BrowserModule } from "@angular/platform-browser";
import { NgModule, APP_INITIALIZER, InjectionToken } from "@angular/core";
import { AppRoutingModule } from "./app-routing.module";
import { AppComponent } from "./app.component";
import { FormsModule, ReactiveFormsModule  } from '@angular/forms';
import { MatTableModule } from "@angular/material/table";
import { BrowserAnimationsModule } from "@angular/platform-browser/animations";
import { MatButtonModule } from "@angular/material/button";
import { MatCheckboxModule } from "@angular/material/checkbox";
import { MatButtonToggleModule } from "@angular/material/button-toggle";
import { MatTooltipModule } from "@angular/material/tooltip";
import { MatIconModule } from "@angular/material/icon";
import { MatListModule } from "@angular/material/list";
import { MatBottomSheetModule } from "@angular/material/bottom-sheet";
import { MatDatepickerModule } from "@angular/material/datepicker"; 
import { MatFormFieldModule } from "@angular/material/form-field";
import { MatPaginatorModule } from "@angular/material/paginator";
import { MatSortModule } from "@angular/material/sort";
import { MatRadioModule } from "@angular/material/radio";
import { MatSelectModule } from "@angular/material/select";
import { MatInputModule } from "@angular/material/input";
import { MatCardModule} from "@angular/material/card";
import { MatMenuModule } from "@angular/material/menu";
import { HTTP_INTERCEPTORS, HttpClientModule, HttpClient } from "@angular/common/http";
import { MsalModule } from "@azure/msal-angular";
import { MsalInterceptor } from "@azure/msal-angular";
import { LogLevel } from 'msal';
import { MatProgressSpinnerModule } from "@angular/material/progress-spinner";
import { MAT_DATE_LOCALE } from "@angular/material/core";
import { MatOptionModule } from "@angular/material/core";
import { MatNativeDateModule } from "@angular/material/core";

import { Constant } from "./shared/Constant";

import { LoaderComponent } from "./loader/loader.component";
import { LoaderService } from "./loader/loader.service";
import { DataService } from "./shared/dataService";

import { ConfigService } from "./shared/configService";
import { ConfigModel } from "./models/config";
import { VersionInAzureService } from "./shared/versionInAzureService";
import { VersionAzureModel } from './models/versionazure';

import { Dashboard } from "./dashboard/dashboard.component";
import { ErrorComponent } from "./error/error.component";
import { Application } from "./application/application.component";
import { ApplicationAdd } from "./application/applicationadd.component";
import { ApplicationEdit } from "./application/applicationedit.component";
import { ApplicationDelete, ApplicationDeleteBottomSheet } from "./application/applicationdelete.component";
import { Authorization } from "./authorization/authorization.component";
import { AuthorizationAdd } from "./authorization/authorizationadd.component";
import { AuthorizationEdit } from "./authorization/authorizationedit.component";
import { AuthorizationDelete, AuthorizationDeleteBottomSheet } from "./authorization/authorizationdelete.component";
import { CurrentAuthorization } from "./currentAuthorization/currentauthorization.component";
import { CurrentAuthorizationAdd } from "./currentAuthorization/currentauthorizationadd.component";
import { CurrentAuthorizationEdit } from "./currentAuthorization/currentauthorizationedit.component";
import { CurrentAuthorizationDelete, CurrentAuthorizationDeleteBottomSheet } from "./currentAuthorization/currentauthorizationdelete.component";
import { HistoryAuthorization } from "./historyAuthorization/historyauthorization.component";


Constant.initialize(); // Initialise all settings from "appsettings.json" file.

export const configFactory = (configService: ConfigService) => {
  return () => configService.loadConfig();
};

export const verisonInAzureFactory = (versionInAzureService: VersionInAzureService) => {
  return () => versionInAzureService.loadCurrentVersionInAzure();
};

export function loggerCallback(logLevel, message, piiEnabled) {
  console.log("client logging -> " + message);
}

export const protectedResourceMap: [string, string[]][] = [
  [Constant.API_URL + Constant.GRAPH_Url, [Constant.GRAPH_UserReadScope]],
  [Constant.API_URL + Constant.API_Operations_Url, [Constant.CallB2CWebScope]],  
  [Constant.API_URL + Constant.API_Application_Url, [Constant.CallB2CWebScope]],
  [Constant.API_URL + Constant.API_Authorization_Url, [Constant.CallB2CWebScope]],
  [Constant.API_URL + Constant.API_CurrentAuthorization_Url, [Constant.CallB2CWebScope]],
  [Constant.API_URL + Constant.API_HistoryAuthorization_Url, [Constant.CallB2CWebScope]],
  [Constant.API_URL + "identity", [Constant.CallB2CWebScope]]
];

@NgModule({
  declarations: [
    AppComponent,
    Dashboard,
    LoaderComponent,
    ErrorComponent,
    Application,
    ApplicationAdd,
    ApplicationEdit,
    ApplicationDelete,
    ApplicationDeleteBottomSheet,
    Authorization,
    AuthorizationAdd,
    AuthorizationEdit,
    AuthorizationDelete,
    AuthorizationDeleteBottomSheet,
    CurrentAuthorization,
    CurrentAuthorizationAdd,
    CurrentAuthorizationEdit,
    CurrentAuthorizationDelete,
    CurrentAuthorizationDeleteBottomSheet,
    HistoryAuthorization
  ],
  imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule,    
    MatTableModule,
    BrowserAnimationsModule,
    MatButtonModule,
    MatCheckboxModule,
    MatPaginatorModule,
    MatSortModule,
    MatIconModule,
    MatListModule,
    MatButtonToggleModule,
    FormsModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatRadioModule,    
    MatSelectModule,
    MatInputModule,
    MatTooltipModule,
    MatDatepickerModule,    
    MatBottomSheetModule,
    MatCardModule, 
    MatProgressSpinnerModule,
    MatOptionModule,
    MatNativeDateModule,
    MatMenuModule,

    MsalModule.forRoot({
      clientID: Constant.AzureClientId,
      authority: Constant.AzureAuthority, 
      redirectUri: Constant.RedirectURL, 
      validateAuthority : Constant.TRUE,
      cacheLocation: Constant.SessionStorage, 
      storeAuthStateInCookie: Constant.TRUE, // dynamically set to true when IE11
      postLogoutRedirectUri: Constant.PostLogoutRedirectURL, 
      navigateToLoginRequestUrl : Constant.TRUE,
      popUp: Constant.FALSE,
      consentScopes: [Constant.GRAPH_UserReadScope, Constant.OpenIdScope, Constant.ProfileScope, Constant.CallB2CWebScope],
      unprotectedResources: ["https://angularjs.org/", Constant.FolderPath_AppSettings, Constant.FolderPath_VersionAzureSettings],
      protectedResourceMap : protectedResourceMap,
      logger: loggerCallback,
      correlationId: Constant.CorrelationId,
      level: LogLevel.Verbose,
      piiLoggingEnabled: Constant.TRUE,
    }) 
  ],
  exports: [MatIconModule, MatButtonModule],
  entryComponents: 
  [
    ApplicationDeleteBottomSheet,
    AuthorizationDeleteBottomSheet,
    CurrentAuthorizationDeleteBottomSheet
  ],
  providers: [
    LoaderService,
    DataService,
    MatDatepickerModule,
    { 
      provide: HTTP_INTERCEPTORS, 
      useClass: MsalInterceptor, 
      multi: Constant.TRUE 
    },
    { 
      provide: MAT_DATE_LOCALE, 
      useValue: Constant.Date_AU_Locale 
    },
    {
      provide: APP_INITIALIZER,
      useFactory: configFactory,
      deps: [ConfigService],
      multi: Constant.TRUE
    },
    {
      provide: APP_INITIALIZER,
      useFactory: verisonInAzureFactory,
      deps: [VersionInAzureService],
      multi: Constant.TRUE
    } 
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }

// Powershell -> in C:\Users\rp0002\GitAzureAD-B2CBroker\B2CBrokerApp\src\app  - Run the Following.
// npm install


import { NgModule } from "@angular/core";
import { Routes, RouterModule } from "@angular/router";
import { Dashboard } from "./dashboard/dashboard.component";
import { Constant } from "./shared/Constant";
import { MsalGuard } from "@azure/msal-angular";
import { ErrorComponent } from "./error/error.component";
import { Application } from "./application/application.component";
import { ApplicationAdd } from "./application/applicationadd.component";
import { ApplicationEdit } from "./application/applicationedit.component";
import { ApplicationDelete } from "./application/applicationdelete.component";
import { Authorization } from "./authorization/authorization.component";
import { AuthorizationAdd } from "./authorization/authorizationadd.component";
import { AuthorizationEdit } from "./authorization/authorizationedit.component";
import { AuthorizationDelete } from "./authorization/authorizationdelete.component";
import { CurrentAuthorization } from "./currentAuthorization/currentauthorization.component";
import { CurrentAuthorizationAdd } from "./currentAuthorization/currentauthorizationadd.component";
import { CurrentAuthorizationEdit } from "./currentAuthorization/currentauthorizationedit.component";
import { CurrentAuthorizationDelete } from "./currentAuthorization/currentauthorizationdelete.component";
import { HistoryAuthorization } from "./historyAuthorization/historyauthorization.component";

const routes: Routes = [
  { path: Constant.DefaultRoute, component: Dashboard },
  { path: Constant.Dashboard, component: Dashboard },
  { path: Constant.ErrorPage, component: ErrorComponent },
  { path: Constant.Application, component: Application, canActivate: [MsalGuard] },
  { path: Constant.ApplicationAdd, component: ApplicationAdd, canActivate: [MsalGuard] },
  { path: Constant.ApplicationEdit, component: ApplicationEdit, canActivate: [MsalGuard] },
  { path: Constant.ApplicationDelete, component: ApplicationDelete, canActivate: [MsalGuard] },
  { path: Constant.Authorization, component: Authorization, canActivate: [MsalGuard] },
  { path: Constant.AuthorizationAdd, component: AuthorizationAdd, canActivate: [MsalGuard] },
  { path: Constant.AuthorizationEdit, component: AuthorizationEdit, canActivate: [MsalGuard] },
  { path: Constant.AuthorizationDelete, component: AuthorizationDelete, canActivate: [MsalGuard] },
  { path: Constant.CurrentAuthorization, component: CurrentAuthorization, canActivate: [MsalGuard] },
  { path: Constant.CurrentAuthorizationAdd, component: CurrentAuthorizationAdd, canActivate: [MsalGuard] },
  { path: Constant.CurrentAuthorizationEdit, component: CurrentAuthorizationEdit, canActivate: [MsalGuard] },
  { path: Constant.CurrentAuthorizationDelete, component: CurrentAuthorizationDelete, canActivate: [MsalGuard] },
  { path: Constant.HistoryAuthorization, component: HistoryAuthorization, canActivate: [MsalGuard] }
];

@NgModule({
  imports: [RouterModule.forRoot(routes,
    {
      useHash: Constant.FALSE,
      enableTracing: Constant.TRUE
    })],
  exports: [RouterModule]
})
export class AppRoutingModule { }


